<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>语义特征指导下的深度对比多视图聚类</title>
      <link href="/2024/04/29/%E8%AF%AD%E4%B9%89%E7%89%B9%E5%BE%81%E6%8C%87%E5%AF%BC%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/"/>
      <url>/2024/04/29/%E8%AF%AD%E4%B9%89%E7%89%B9%E5%BE%81%E6%8C%87%E5%AF%BC%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>摘要</strong>：最近，对比学习在多视图聚类领域取得了很好的效果。然而，忽略语义一致性的正负样本构造机制导致了假阴性对的产生，限制了现有算法性能的进一步提升。针对这一问题，本文提出了语义特征指导下的深度对比多视图聚类框架( Deep Contrastive Multi-view Clustering under Semantic feature guidance，DCMCS )来缓解假阴性对的影响。具体来说，首先从原始特征中提取特定视角的特征，并根据视角重要性进行融合，得到融合视角特征。为了减轻视图隐私信息的干扰，通过簇级对比学习特定视图和融合视图的语义特征，并将其级联以度量实例的语义相似度。通过最小化由语义相似度加权的实例级对比损失，DCMCS自适应地削弱了假阴性对之间的对比学习。在几个公共数据集上的实验结果表明，所提出的框架优于最先进的方法。</p><p><strong>关键词：多视图聚类, 对比学习, 假阴性对, 语义特征</strong></p><h2 id="动机"><strong>动机</strong></h2><p>多视图聚类( multi-view clustering，MVC )在最近几年引起了人们的兴趣，并在生物学、医学、社交网络、农业等领域得到了广泛的应用。传统的MVC方法包括非负矩阵分解、隐表示学习、图学习和张量学习。许多传统的MVC方法存在表示效果差和计算复杂度高的问题，导致其在具有真实数据的复杂场景中性能有限。深度学习以其强大的表征能力开发出优越的特征，因此深度MVC逐渐流行起来。深度MVC方法可以分为4个子类：子空间聚类、基于图的深度聚类、深度表示聚类和谱聚类。与其他方法相比，深度表示聚类通常采用简单的编码器-解码器结构，并且可能更加灵活。</p><p>有效的深度MVC依赖于从多视图数据中学习判别性的公共信息。最近，对比学习被融入到深度MVC中，因为它能够捕获高层语义而丢弃无关信息。有研究者设计融合网络提取公共信息。有研究者在不同的特征层执行不同的目标，以解决一致性和重建目标之间的冲突。研究者通过对比学习建立三元组特征，使用面向特征对齐，面向共性和簇级一致性。</p><h2 id="问题"><strong>问题</strong></h2><p>尽管这些基于对比学习的深度MVC方法取得了重要进展，但仍然存在一些问题需要解决：( 1 )对于直接应用对比损失，如InfoNCE，许多方法的性能会受到假阴性对的影响。最小化对比损失可能会由于假阴性对而增加共享相同聚类标签的实例的特征相异性，这与聚类目标相矛盾，并导致不利于聚类的表示学习。( 2 )一些方法对特定视图进行融合，得到包含公共信息的融合视图。然而，视图私有信息不可避免地被引入到视图特征的融合中，并转移到对比学习中，干扰了聚类的质量。</p><h2 id="创新点"><strong>创新点</strong></h2><p>在本文中，我们提出了一种新颖的语义引导的多视图对比聚类框架来解决上述问题。如图1所示，我们的框架由特定视角的特征融合模块和跨视角的双层对比模块组成。在特定视图特征融合模块中，自编码器用于生成特定视图特征，加权融合用于生成融合视图特征。跨视图双层对比融合模块采用两个一致性目标：语义引导的实例级对比学习和簇级对比学习。通过语义特征度量的实例对权重来减轻假阴性对的影响。此外，为了减少视图私有信息的影响，在计算实例对权重时集中了公共信息。与之前的工作相比，我们的贡献如下：</p><ol><li>为了减少实例级对比学习中假阴性对的影响，提出了DCMCS框架。通过使用从语义特征中获得的实例对权重来学习聚类友好特征，使对比学习的目标与聚类目标保持一致。</li><li>在计算实例对权重时，融合视图的公共信息集中在DCMCS中。它缓解了视图-隐私信息在融合视图中的干扰，以达到更好的聚类结果。</li><li>在实验中，我们展示了实例对权重和融合视图的公共信息如何有效地工作。在几个公共数据集上的实验结果表明，我们的框架优于最先进的方法。</li></ol><h2 id="方法"><strong>方法</strong></h2><p>在这一部分中，我们首先解释了框架中使用的定义和要达到的目标。接下来，我们介绍了框架的体系结构。最后给出了总损耗和整个优化过程。</p><p><img src="https://s2.loli.net/2024/04/29/VkDpRiA4X1tHhPB.jpg" alt="img"></p><p>图1  DCMCS框架图</p><p>图1中的Zv表示特定视图特征，Hv表示实例级特征，Cv表示语义特征，重建目标Lcon在Zv上单独进行。在语义引导的对比学习( SGCL )和簇级对比学习( CLCL )模块中，分别在实例级特征和簇级特征上进行了两次对比损失(即Li和Lc )。此外，RC表示由语义特征生成的权重矩阵，以建立Li中负对之间的关系。</p><h3 id="符号定义"><strong>符号定义</strong></h3><p>给定一个具有V个视图和N个样本的多视图数据集χ = {X^v^∈R~N × D^v^~ }^V^v=1，Xv = [ x1v , x2v , … , xNv]表示第v个视图的实例。Dv表示第v个视图的特征维度。考虑到数据集中有K个簇，最终根据N个样本的相似度将其划分为K个簇。</p><h3 id="特定视图特征融合"><strong>特定视图特征融合</strong></h3><p>特定视角特征融合模块使用若干个特定视角自编码器(如图1所示)来提取每个视角的特征。特别地，我们指定了第v个视图的编码器fvθv和解码器gvηv，其中θv和ηv分别是编码器和解码器的参数。编码器fvθv将原始特征投影到特定视图的特征空间</p><p><img src="https://s2.loli.net/2024/04/29/u13UZbTi9ApDEjr.jpg" alt="img"></p><p>其中Zv = [ z1v , z2v , … , zNv]， DCMCS使用解码器gvηv重构zvi，以学习足够的判别信息，避免模型崩溃。</p><p><img src="https://s2.loli.net/2024/04/29/pbxYBwakueRlN1Z.jpg" alt="img"></p><p>所有视图的重建损失定义为:</p><p><img src="https://s2.loli.net/2024/04/29/pGjh4b7Wg2eKuBo.jpg" alt="img"></p><p>加权融合是一种简单有效的方法，通过利用多视图数据的一致性和互补性，获得更具判别性的融合视图特征。考虑到不同视图的重要性，我们使用自适应加权对视图进行融合，得到融合视图特征定义为：</p><p><img src="https://s2.loli.net/2024/04/29/QkSuXHBMKdxYzCy.jpg" alt="img"></p><p>式中：wv为第v个视图的权重，∑Vv=1 wv=1。权重通过损失函数优化得到，反映了不同视图的重要性。</p><h3 id="簇类级对比学习"><strong>簇类级对比学习</strong></h3><p>对比学习由于直接增加了语义相关实例之间的特征相似度，在去除无关信息的同时有效地捕获了高层语义。我们应用簇级对比学习来提高跨多个视图的簇一致性。采用带参数WC的两层线性MLP将视角特征和融合视角特征映射到K维空间。K为聚类数。附加一个Softmax层，得到每个视图的语义特征Cv和融合视图的语义特征C(^),语义特征描述为实例属于每个聚类的概率。实例的聚类标签对应概率最大的聚类。簇级特征Cvj表示为每个实例在第v个视图中属于簇j的概率。</p><p>由于与单个样本对应的多个视图中的实例共享语义信息，因此不同视图中实例的聚类分配概率应该是相似的，并且来自同一簇的簇级特征应该是相似的。簇级对比学习增加了不同簇对应的簇对之间的距离，同时减少了相同簇对应的簇对之间的距离。对于每个融合视图簇级特征c(^) j，{ c(^) j，cvj }为正对，其余簇对为负对。</p><p>余弦相似度用于量化两个簇之间的相似性，具体解释如下：</p><p><img src="https://s2.loli.net/2024/04/29/AyJzspXTOS84V7j.jpg" alt="img"></p><p>式中：&lt;·，·&gt;为点积算子。簇级别的对比损失定义为：</p><p><img src="https://s2.loli.net/2024/04/29/xLt4rcjIlu7AH8w.jpg" alt="img"></p><p>其中τ表示温度系数，H ( C )表示聚类结果的熵。熵的存在避免了陷入平凡解。</p><h3 id="语义引导的实例级对比学习"><strong>语义引导的实例级对比学习</strong></h3><p>正负对构造的质量是决定对比MVC方法性能的重要因素。MVC中一种流行的对比损失函数是InfoNCE</p><p><img src="https://s2.loli.net/2024/04/29/F1WTjQmwqvnJaer.jpg" alt="img"></p><p>InfoNCE将与单个样本对应的不同视图中的实例视为正例对，直接将其他所有非正例实例视为负例对。这容易带来假负对问题，共享相同聚类标签的实例被构造为负对，从而导致聚类不友好的表示学习。为了解决这个问题，我们提出了一种基于实例对权重的语义引导的实例级对比方法。在计算实例对权重时，我们关注的是融合视图的公共信息，而不是仅仅关注具体视图中的信息。考虑了融合视图语义特征和特定视图语义特征中的一致性和互补性。它可以产生更精确的权重，并减少视图私有信息在融合视图中的影响。它产生了优越的聚类结果。</p><p><strong>实例对权重</strong> 由于同一簇中的实例具有相同的语义信息，因此可以利用实例的语义特征来建立实例关系。采用Transformer的注意力机制来评估实例之间的关系，我们首先将所有特定视图的语义特征Cv与融合视图的语义特征C(^) 进行拼接，得到C。</p><p>其中m=(V+1)×K。通过在注意力机制的输入中包含C(^)，我们可以从融合视图中提取更重要的信息，并减少视图-隐私信息的影响。C通过WQ1、WQ2和WO映射到不同的特征空间。</p><p><img src="https://s2.loli.net/2024/04/29/1vJbFK7XYrCnM5e.jpg" alt="img"></p><p>其中Q1∈Rn×M，Q2∈Rn×M，Qo∈Rn×M。我们使用矩阵W = { WQ1，WQ2，WO }作为参数。权重矩阵RC定义为：</p><p><img src="https://s2.loli.net/2024/04/29/ceNkKXDMCbjhHlT.jpg" alt="img"></p><p>权重矩阵RC可以表示实例之间的关系，权重越高，表示实例对的语义特征越相似，属于同一簇的可能性越高。对于负实例对(i ,j)，实例对的权重定义为：1-RCij。</p><p><strong>语义指导下的实例级对比学习</strong> DCMCS应用实例级对比学习来学习跨多个视图的实例一致性。使用单层MLP，获取特定视图的实例级特征Hv和融合视图的实例级特征H(^)。我们将特征MLP的参数记为WH。融合视图和特定视图中属于单个样本的实例被视为正例对，而所有其他非正例实例被视为负例对，融合视图作为锚点。通过实例对权重来减弱对比学习中假阴性对的影响。再次，利用余弦相似度来度量特定视图实例级特征和融合视图实例级特征之间的相似性，语义引导的实例级对比损失函数定义为：</p><p><img src="https://s2.loli.net/2024/04/29/pZKEVIgj4rMG2FX.jpg" alt="img"></p><p>其中τ2表示温度系数，1 - RCij表示实例对权重。RCij由式( 10 )得到。较大的权重RCij表示实例对属于同一簇的可能性较大，实例对权重1 - RCij较小。实例对权重可以减少假阴性对的影响，并产生更好的聚类友好特征。</p><h3 id="优化"><strong>优化</strong></h3><p>最终的整体损失函数定义如下：</p><p><img src="https://s2.loli.net/2024/04/29/BrLMCDhZFUTqm5Y.jpg" alt="img"></p><p>其中λ1和λ2为平衡参数。我们将λ1和λ2设定为1。DCMCS通过融合视图的语义特征获得聚类标签yi：<img src="https://s2.loli.net/2024/04/29/LFNA78gphYQ61Kj.jpg" alt="img"></p><p>得到每个样本的最终聚类结果Y = [ y1 , y2 , … , yN]。我们的优化过程总结如算法1所示。</p><p>算法1</p><p>输入：多视图数据集 Xv；聚类数K；温度参数τ1和τ2；平衡参数λ1和λ2。</p><p>1：通过最小化公式3初始化{θv，ηv }Vv = 1。( 3 )；</p><p>2：通过公式4计算Z(^) ；</p><p>3：最小化公式13优化WH，WC，{θv，ηv }Vv = 1；</p><p>4：通过公式14计算语义标签；</p><p>输出：标签预测Y = [ y1 , y2 , … , yN]。</p><h2 id="实验"><strong>实验</strong></h2><p><strong>评价指标</strong> 聚类有效性通过三个指标进行评估：聚类精度( ACC )、归一化互信息( NMI )和纯度( PUR )。</p><p>**性能分析 表1：**所有方法在四个数据集上的结果。Bold表示最好结果，下划线表示次好结果。</p><p><img src="https://s2.loli.net/2024/04/29/dVNiblTtmGf9Dna.jpg" alt="img"></p><p>表2：所有方法在多视图数据集上的结果。‘ - XV '表明有X个视图可用。</p><p><img src="https://s2.loli.net/2024/04/29/3qNKRkxXEZDifOt.jpg" alt="img"></p><p>在四个数据集上的实验结果如表所示。从中我们可以得到以下发现：( 1 )我们的DCMCS在所有指标上都取得了最好的结果。在Synthetic3d数据集上，DCMCS在NMI上的表现比最好的可比方法AECoDDC好2 %。这是因为我们采用了语义引导的实例级对比学习，削弱了假阴性对的影响。( 2 )给出了对比方法中实例级对比学习和簇级对比学习的使用情况。由于我们同时考虑了两者并引入了实例对权重，因此我们的DCMCS表现更好。DCMCS将实例级的对比学习与聚类目标相结合，通过语义特征而不是视图特定的特征来获取实例关系。</p><h2 id="结论"><strong>结论</strong></h2><p>在本文中，我们提出了一个语义引导的对比多视图聚类框架。加权融合是根据每个视图的重要性来融合视图的特征。为了减少假阴性对，通过注意力机制从融合视图和特定视图的语义特征中获取实例对权重。此外，我们通过专注于融合视图的公共信息来最小化视图私有信息的影响。在多个公共数据集上的实验结果表明，DCMCS优于当前最先进的方法。我们的框架的缺点是，当数据集中存在超类时，可以简单地分配错误的簇，这导致实例被分裂成几个簇。</p><p><strong>参考文献:</strong></p><ol><li>Bauckhage, C.: K-means clustering is matrix factorization. arXiv preprint arXiv:1512.07548 (2015) 11</li><li>Chen, C., Li, X., Ng, M.K., Yuan, X.: Total variation based tensor decomposition for multi-dimensional data with time dimension. Numerical Linear Algebra with Applications 22(6), 999–1019 (2015) 1</li><li>Chen, J., Mao, H., Peng, D., Zhang, C., Peng, X.: Multiview clustering by consensus spectral rotation fusion. IEEE Transactions on Image Processing (2023) 1, 3</li><li>Chen, J., Mao, H., Woo, W.L., Peng, X.: Deep multiview clustering by contrasting cluster assignments. arXiv preprint arXiv:2304.10769 (2023) 3, 9, 12</li><li>Chen, M.S., Lin, J.Q., Li, X.L., Liu, B.Y., Wang, C.D., Huang, D., Lai, J.H.: Representation learning in multi-view clustering: A literature review. Data Science and Engineering 7(3), 225–241 (2022) 8</li><li>Chen, T., Kornblith, S., Norouzi, M., Hinton, G.: A simple framework for contrastive learning of visual representations. In: International conference on machine learning. pp. 1597–1607. PMLR (2020) 2, 3, 6</li><li>Chen, W., Wang, H., Liang, C.: Deep multi-view contrastive learning for cancer subtype identification. Briefings in Bioinformatics 24(5), bbad282 (2023) 1</li><li>Chen, Z., Li, Y., Lou, K., Zhao, L.: Incomplete multi-view clustering with complete view guidance. IEEE Signal Processing Letters (2023) 3</li><li>Cui, C., Ren, Y., Pu, J., Pu, X., He, L.: Deep multi-view subspace clustering with anchor graph. arXiv preprint arXiv:2305.06939 (2023) 3</li><li>Fang, U., Li, M., Li, J., Gao, L., Jia, T., Zhang, Y.: A comprehensive survey on multi-view clustering. IEEE Transactions on Knowledge and Data Engineering (2023) 1</li><li>Fei-Fei, L., Fergus, R., Perona, P.: Learning generative visual models from few training examples: An incremental bayesian approach tested on 101 object categories. In: 2004 conference on computer vision and pattern recognition workshop. pp. 178–178. IEEE (2004) 9</li><li>Guo, J., Ye, J.: Anchors bring ease: An embarrassingly simple approach to partial multi-view clustering. In: Proceedings of the AAAI conference on artificial intelligence. vol. 33, pp. 118–125 (2019) 1</li><li>Guo, X., Gao, L., Liu, X., Yin, J.: Improved deep embedded clustering with local structure preservation. In: Ijcai. vol. 17, pp. 1753–1759 (2017) 4</li><li>He, K., Fan, H., Wu, Y., Xie, S., Girshick, R.: Momentum contrast for unsupervised visual representation learning. In: Proceedings of the IEEE/CVF conference on computer vision and pattern recognition. pp. 9729–9738 (2020) 3</li><li>Hu, S., Zou, G., Zhang, C., Lou, Z., Geng, R., Ye, Y.: Joint contrastive triplelearning for deep multi-view clustering. Information Processing &amp; Management 60(3), 103284 (2023) 2, 3</li><li>Hu, W., Miyato, T., Tokui, S., Matsumoto, E., Sugiyama, M.: Learning discrete representations via information maximizing self-augmented training. In: International conference on machine learning. pp. 1558–1567. PMLR (2017) 6</li><li>Jin, Y., Li, C., Li, Y., Peng, P., Giannopoulos, G.A.: Model latent views with multi-center metric learning for vehicle re-identification. IEEE Transactions on Intelligent Transportation Systems 22(3), 1919–1931 (2021) 1</li><li>Kang, Z., Shi, G., Huang, S., Chen, W., Pu, X., Zhou, J.T., Xu, Z.: Multi-graph fusion for multi-view spectral clustering. Knowledge-Based Systems 189, 105102 (2020) 1</li><li>Ke, G., Hong, Z., Zeng, Z., Liu, Z., Sun, Y., Xie, Y.: Conan: contrastive fusion networks for multi-view clustering. In: 2021 IEEE International Conference on Big Data (Big Data). pp. 653–660. IEEE (2021) 2, 9</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 多视图聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对比学习中的损失函数</title>
      <link href="/2024/04/15/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2024/04/15/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>损失目标函数：衡量 模型的预测输出 和 固定的目标之间的 difference。</p><p>​    损失函数有以下几种类别：</p><ul><li>判别式：一张图片 打成 有序号的 9 宫格，给 中间的 第 5 格 和 剩下随机挑一格，预测随机挑的这一格是中间 第5 格 的方位（8个方位可选）</li><li>生成式：Auto-encoder（生成式网络的做法）, 输入一张原图 or 一张被干扰的图，经过编码器、解码器 重构输入的图，衡量是原图 和 重构图 之间的差异</li><li>对比学习：目标不固定，训练过程中不断改变。目标有编码器抽出来的特征（MoCo 的字典）而决定 。测量 样本对 在特征空间的相似性。相似样本离得近，不相似样本离得远</li><li>对抗学习 ：衡量两个概率分布之间的差异 。i.e. GAN</li></ul><p>代理任务：不是大家实际感兴趣的任务 (检测、分类、分割实际应用任务)，而是为了 学习一个好的数据特征表示<br>损失函数：和代理任务可以分开研究。 MoCo 的创新点在损失函数，又大又一致的字典 影响 info NCE 目标函数的计算</p><p>代理任务有以下几种：</p><ul><li>denoising auto-encoders 重建整张图</li><li>context auto-encoders 重建某个 patch</li><li>cross-channel auto-encoders (colorization) 给图片上色当自监督信号</li><li>pseudo-labels 图片生成伪标签</li><li>exemplar image 给同一张图片做不同的数据增广，它们都属于同一个类。</li><li>patch ordering 九宫格方法：打乱了以后预测 patch 的顺序, or 随机选一个 patch 预测方位 eight positions</li><li>利用视频的顺序做 tracking</li><li>做聚类的方法 clustering features</li></ul><p>对比学习和代理任务的关系：</p><p>不同的代理任务 可以和 某种形式的对比学习的目标函数 配对使用</p><ul><li>MoCo 论文里 instance discrimination 个体判别方法  ++++ examplar based 代理任务相关</li><li>CPC contrastive predictive coding 用上下文信息预测未来 ++++ context auto-encoding 上下文自编码</li><li>CMC contrastive multiview coding 利用一个物体的不同视角做对比 ++++ colorization 图片上色（同一个图片的 2 个视角：黑白 和 彩色）</li></ul><p>​假设有一个编码好的query q，一系列编码好的样本k0 k1…（看作字典里的key）。</p><p>​     假设字典中只有一个key和query是匹配的</p><p>对比学习的目标函数最好能满足如下要求：q和k positive相似的时候，loss的值比较低，q和其他k不相似的时候，loss的值也应该低。到这个状态，模型差不多就训练好了。反之，loss应该高，惩罚模型，让模型赶紧更新参数。</p><p>MoCo中的目标函数：InfoNCE。</p><ul><li>NCEloss：noise contrastive estimation把超级多分类的问题变成二分类问题，就还可以很好的使用softmax操作。noise contrastive：解决类别多的问题。因为类别数太多（每个图片是一个类），没法算softmax，所以没法算目标函数。NCEloss把问题简化为一个二分类问题：数据类别和噪声类别。estimation：把所有剩下的图片都当做负样本，还是太多了，在数据集上选一些负样本算loss就可以了，只是一个估计。（如果样本选的很少，就不能近似，效果就会差）所以moco说要尽可能大的字典，因为越大就能提供一个越好的近似。</li><li>infoNCEloss：觉得2分类（数据样本和噪声样本）不太合理，应该看作多分类问题。温度超参数τ：标量。一般是用来控制分布的形状的，设置的过大那么对比损失对所有的负样本一视同仁，导致模型学习没有轻重。如果设置的过小，互让模型只关注哪些特别困难的负样本，会导致模型很难收敛，或者学好的特征不好泛化；</li></ul><p>​    基于点积度量的相似性， 形式如下：<img src="https://s2.loli.net/2024/04/16/Cw7ZYDQH5vE1OKs.png" alt="image-20240416151011515"></p><p>其中q=f~q~(x^q^)  , x^q^是锚点（查询）样本，k=f~k~(x^k^)  ,K是负样本个数，T是温度超参数，用来控制logit输出的分布</p><p>SimCLR的目标函数：NT—Xent</p><p><img src="https://s2.loli.net/2024/04/16/htjB9VRFC4fgGoM.png" alt="image-20240416161842233"></p><p>其中<img src="https://s2.loli.net/2024/04/16/yU3LGCn6HxQJt7W.png" alt="image-20240416161935501"></p><blockquote><p>NT—Xent和InfoLoss的共同点和区别：</p><p>共同点：目标相同，都是最大化正样本对之间的相似度，形式类似，都用了softmax函数和温度参数</p><p>区别：InfoLoss更加通用</p></blockquote><p>CPC的目标函数：InfoLoss</p><p><img src="https://s2.loli.net/2024/04/16/GV7D9QpIT8nWUil.png" alt="image-20240416163651233"></p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 多视图聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DCP与MFLVC的异同</title>
      <link href="/2024/04/08/DCP%E4%B8%8EMFLVC%E7%9A%84%E5%BC%82%E5%90%8C/"/>
      <url>/2024/04/08/DCP%E4%B8%8EMFLVC%E7%9A%84%E5%BC%82%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Reconstruction-Loss（重构损失）">Reconstruction Loss（重构损失）</h2><h3 id="DCP的视图重构">DCP的视图重构</h3><p>为了建模不同视图之间的相关性，我们首先为每个视图单独学习一个潜在子空间。具体来说，第v个视图通过特定于视图的自编码器通过最小化来获得表示Zv</p><img src="https://s2.loli.net/2024/04/08/MG5NOjrq6mzQJRB.png" alt="image-20240408145926088" style="zoom:80%;" /><p>其中X~t~^v^表示X^v^的第t个样本，g ( v )表示第v个视图的解码器.表示Z~t~^v^定义为Z~t~^v^ = f ( v ) ( X~t~^v^)，( 20 )式中f ( v )为视图v的编码器。得益于等式( 20 )，我们的方法可以保留尽可能多的视图信息，同时避免平凡解。</p><p>arch1=[20, 1024, 1024, 1024, 128]</p><p>自编码器的架构如下：</p><p><img src="https://s2.loli.net/2024/04/08/2JuPz75bvxkrTds.png" alt="image-20240408152616753"></p><h3 id="MFLVC的视图重构">MFLVC的视图重构</h3><p>所有视图的重建目标被表述为：</p><p><img src="https://s2.loli.net/2024/04/08/X1Nh9ldtaZxEGbg.png" alt="image-20240408155613704"></p><p>也是通过自编码器来学习有效表示</p><p>其架构如下：</p><p><img src="https://s2.loli.net/2024/04/08/2SzJmnpIs84kKCj.png" alt="image-20240408160236961"></p><h2 id="Contrastive-LOSS（对比损失）">Contrastive LOSS（对比损失）</h2><h3 id="DCP的对比学习">DCP的对比学习</h3><p>在自编码器学习到的潜在特征空间中，我们进行对比学习，以最大化不同视图之间的一致性。我们提出直接最大化不同视图表示之间的互信息。从数学上讲，</p><img src="https://s2.loli.net/2024/04/08/hit1dD3Vza8IJSe.png" alt="image-20240408212351954" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 多视图聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对比多视图聚类的多层次特征学习</title>
      <link href="/2024/04/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E6%AF%94%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB%E7%9A%84%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%89%B9%E5%BE%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E6%AF%94%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB%E7%9A%84%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%89%B9%E5%BE%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>由于多视角数据或多模态数据能够提供共同的语义来提高的学习效果，近年来受到越来越多的关注。在文献中，现有的MVC方法大致可以分为两类，即传统方法和深度方法。传统的MVC方法基于传统的机器学习方法进行聚类任务，许多传统的MVC方法存在表示能力差、计算复杂度高等缺点，导致其在具有真实数据的复杂场景中性能受限。</p><p>深度MVC方法由于突出的表示能力逐渐成为了社区流行的趋势。以往的深度MVC方法可以细分为两个子群，即两阶段方法和一阶段方法。两阶段深度MVC方法侧重于从多个视图中分别学习显著特征并执行聚类任务。一阶段深度MVC方法将特征学习与聚类任务嵌入到统一的框架中，实现端到端的聚类。</p><p>本文提出了一种新的多层次特征学习框架用于对比多视图聚类(简称MFLVC)，如图1所示。我们的目标包括：</p><p>( 1 )设计一个无融合的MVC模型，以避免融合所有视图之间的不良视图-隐私信息；</p><p>( 2 )为每个视图中的样本生成不同级别的特征，包括低级特征、高级特征和语义标签/特征。为此，我们首先利用自编码器从原始特征中学习低层特征，然后在低层特征上叠加两个MLP得到高层特征和语义标签。每个MLP由所有视图共享，有利于过滤掉视图私有信息。此外，我们将语义标签作为锚点，结合高层特征中的聚类信息来提高聚类效果。</p><p>在该框架中，重建目标由低层特征实现，两个一致性目标分别由高层特征和语义标签实现。此外，这两个一致性目标通过对比学习进行，使得高层特征专注于挖掘跨所有视图的共同语义，并使得语义标签分别代表一致的类标签进行多视图聚类。</p><p>该方法所作贡献如下：</p><ul><li>我们设计了一种无融合的MVC方法，在不同的特征空间进行不同的目标，以解决重建和一致性目标之间的冲突。这样，我们的方法能够有效地探索所有视图之间的共同语义，并避免它们毫无意义的视图-私有信息。</li><li>我们提出了一个灵活的多视角对比学习框架，可以同时实现高层特征和语义标签的一致性目标。高层特征具有良好的流形结构，代表了共同的语义，能够提高语义标签的质量。</li></ul><p><img src="https://s2.loli.net/2024/04/05/iNdZSzxDchy5GjL.png" alt="image-20240405155219596"></p><blockquote><p>MFLVC的框架。我们避免了多层次特征学习中的直接特征融合，即从每个视图的原始特征Xm中学习低层特征Zm、高层特征Hm和语义标签Qm。重建目标Lm Z在Zm上单独进行。两个一致性目标(即LH和LQ)分别在{ Hm } M m = 1和{ Qm } M m = 1上进行。此外，LP被优化以利用{ Hm } M m = 1的集群信息来提高{ Qm } M m = 1的集群有效性。</p></blockquote><h2 id="方法">方法</h2><p>原始特征:多视图数据集{ Xm∈RN × Dm } mM = 1包含N个跨M个视图的样本，其中xm i∈RDm表示第m个视图的Dm维样本。该数据集被视为原始特征，其中多个视图有K个共同的聚类模式待发现。</p><h3 id="动机">动机</h3><p>所有视图的重建目标被表述为：</p><img src="https://s2.loli.net/2024/04/06/15OckzTWHx9lRmD.png" alt="image-20240406143509400" style="zoom:67%;" /><p>E是编码器，D是解码器，Z=E(X)</p><ol><li>许多MVC方法将所有视图的特征{ Zm } mM = 1进行融合，以获得所有视图的共同表示。这样，通过直接对融合特征进行聚类，将多视图聚类任务转化为单视图聚类任务。然而，每个视图Zm的特征既包含共同的语义，也包含视图私有信息。后者是没有意义的，甚至是误导的，这可能会干扰融合特征的质量，导致聚类效果不佳。</li><li>一些MVC方法通过在{ Zm } mM = 1上执行一致性目标来学习一致的多视图特征以探索共同的语义，例如最小化所有视图之间相关特征的距离。一致性目标和重建目标被推到相同的特征上，因此它们的冲突可能会限制{ Zm } mM = 1的质量。例如，一致性目标旨在学习共同的语义，而重建目标则希望保持视图的私有信息。</li></ol><p>针对上述挑战，本文提出了一种新的用于对比多视角聚类的多层次特征学习框架( MFLVC )，如图1所示。特别地，为了减少视图私有信息的不利影响，我们的框架避免了直接的特征融合，为每个视图构建了一个多层次的特征学习模型。为了缓解一致性目标和重构目标之间的冲突，我们提出将它们在不同的特征空间中进行，其中一致性目标通过下面的多视角对比学习来实现。</p><h3 id="多视图对比学习">多视图对比学习</h3><p>我们将{ Zm } mM = 1作为低层特征，并学习另一个层次特征，即高层次特征。为此，我们在{ Zm } mM = 1上堆叠一个特征MLP，得到高层特征{ Hm } mM = 1，其中hm i∈RH，特征MLP是一个单层线性MLP，记为F ( { Zm } mM = 1 ; WH)。</p><p>在低层特征空间中，我们利用重建目标Eq . ( 1 )保留{ Zm } mM = 1的表示能力，避免模型崩溃问题。在高层特征空间中，我们进一步通过对比学习实现一致性目标，使{ Hm } mM = 1专注于学习所有视图的共同语义。</p><p>具体来说，每个高层特征hm i都有( MN - 1)特征对，其中{ hm i，hn i } n ̸ = m为( M - 1)正特征对，其余M个( N-1 )特征对为负特征对。</p><p>在对比学习中，正对的相似性应该最大化，负对的相似性应该最小化。应用余弦距离来衡量两个特征之间的相似度：然后，Hm和Hn之间的特征对比损失公式为：</p><p><img src="https://s2.loli.net/2024/04/07/oeIwDKsjRUtPFfV.png" alt="image-20240407155827010"></p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 多视图聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多视图聚类的研究</title>
      <link href="/2024/04/04/%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
      <url>/2024/04/04/%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>在大数据时代，数据产生于不同的来源或从不同的视角观察。这些数据统称为多视图数据。多视图聚类( Multi-view Clustering，MvC )旨在利用多个视图之间的互补和共识信息。本文根据涉及的机制和原理主要把算法分为以下五类：协同训练风格算法、多核学习、多视图图聚类、多视图子空间聚类和多任务多视图聚类。</p><h2 id="介绍">介绍</h2><h2 id="MvC的原则">MvC的原则</h2><h2 id="多视图聚类算法">多视图聚类算法</h2><h3 id="协同训练算法">协同训练算法</h3><p>算法思想：这类方法旨在最大限度地在所有观点之间达成共识，并达成最广泛的共识。</p><p><img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231120204403660.png" alt="image-20231120204403660"></p><p>算法交替训练，通过利用先验信息或相互学习知识来最大化两个不同视图的一致性。需要注意的是，协同训练的成功主要依赖于3个假设：( 1 )充分性：每个视图都足以独立完成学习任务；( 2 )兼容性：目标函数在两个视图中以高概率输出对共现特征的相同预测；( 3 )条件独立性：所有视图都在条件独立性中提供学习标签。实际训练中<strong>难以满足条件独立性</strong>（因为协同训练的核心就是利用共享数据相互学习）。</p><p>实例：<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231120210614154.png" alt="image-20231120210614154"></p><p>为了约束另一个视图的相似图，从一个视图进行谱嵌入。通过迭代地执行这个过程，两个视图的聚类趋于彼此。</p><blockquote><p>谱嵌入：谱嵌入是一种将数据点映射到低维空间的技术，通过这种映射可以保留数据点之间的相似性和结构信息，谱也指拉普拉斯矩阵的特征向量。在本算法中是用另外一个视图的判别特征向量对这个视图的相似矩阵进行点积得到新的相似矩阵</p><p>判别特征向量：对拉普拉斯矩阵进行特征分解，得到特征值和特征向量。选取前几个特征值对应的特征向量作为判别特征向量</p></blockquote><h3 id="多核学习">多核学习</h3><p>算法思想：不同的预定义核用于处理不同的视图。然后将这些核进行线性或非线性组合，从而得到一个统一的核。MvC环境下，基于多核学习的MvC旨在对一组预定义的核进行最优组合，以提高聚类性能。</p><p><img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231121142553382.png" alt="image-20231121142553382"></p><p>一个基本的问题是找到一种方法来选择合适的核函数并将这些核函数进行最优组合。</p><p>实例：<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231121142846795.png" alt="image-20231121142846795"></p><ol><li><p>在每个视图上使用核主成分分析对原始数据进行降维，得到低维的多视图数据。</p></li><li><p>将设计的加权高斯核应用在低维多视图数据上。该步骤驱动每个视图和聚类中心的权重</p></li><li><p>经过有限次迭代后，得出最终的聚类结果。</p><blockquote><p>核主成分分析( KPCA)可实现数据的非线性降维，用于处理线性不可分的数据集。大致思路是：对于输入空间中的矩阵  ，我们先用一个非线性映射把 中的所有样本映射到一个高维甚至是无穷维的空间(称为特征空间)，(使其线性可分)，然后在这个高维空间进行PCA降维。</p></blockquote></li></ol><h3 id="多视图图聚类">多视图图聚类</h3><p>算法思想：多视图图聚类旨在找到一个横跨所有视图的融合图，然后在此基础上使用图割算法或其他技术(例如,谱聚类)。</p><p><img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231121154426996.png" alt="image-20231121154426996"></p><p>在这个类别中，文献综述分为三个部分，即基于图的MvC，基于网络的MvC和基于谱的MvC。</p><h4 id="基于图的MvC">基于图的MvC</h4><h2 id="总结和探讨">总结和探讨</h2><h3 id="五种算法的优缺点">五种算法的优缺点</h3><ul><li>协同算法算法：可以通过交流信息来交互增强不同视图的聚类。然而，当视图数量超过三个时，它们是难以解决的。</li><li>多核学习：继承了核的优点，但也带来了较高的计算复杂度。</li><li>多视图图聚类：引入谱图理论，同时依赖于构造的亲和度(或相似度)矩阵。</li><li>多视图子空间聚类：具有直接的可解释性，同时也具有初始化依赖性。</li><li>多任务多视图：继承了多任务聚类和多视图聚类的特性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 多视图聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多视图的对比学习编码</title>
      <link href="/2024/04/04/%E5%A4%9A%E8%A7%86%E5%9B%BE%E7%9A%84%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A0%81/"/>
      <url>/2024/04/04/%E5%A4%9A%E8%A7%86%E5%9B%BE%E7%9A%84%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>人类通过许多感官通道来观察世界，如左眼观察的长波长光通道，或右耳听到的高频振动通道。每个视图都是嘈杂和不完整的，但重要的因素，如物理、几何和语义，往往在所有视图(例如, &quot;狗&quot;可以被看到、听到和感觉到)之间共享。</p><p>我们学习一个旨在最大化同一场景不同视图之间的互信息但在其他方面是紧凑的表示。我们的方法适用于任意数量的视图，并且是视图无关的。</p><h2 id="介绍">介绍</h2><p>编码理论中的一个基本思想是学习压缩表示，这些表示可以被用来重构原始数据。这种思想以自动编码器和生成模型的形式出现在当代表示学习中，它们试图尽可能无损地表示一个数据点或分布。然而，无损表示可能并不是我们真正想要的，事实上实现它是微不足道的-原始数据本身就是无损表示。相反，我们可能更喜欢保留&quot;好&quot;的信息(信号)而丢弃其余的信息(噪声)。如何才能识别什么信息是信号，什么是噪声?</p><p>我们认为好的比特是在世界的多个视图之间共享的比特，例如在视觉，声音和触觉等多种感觉模态之间。在这种视角下，&quot;狗的存在&quot;是好的信息，因为狗可以被看到、听到和感觉到，但&quot;相机姿态&quot;是坏的信息，因为相机的姿态对成像场景的声学和触觉特性几乎没有影响。</p><p>我们采用对比学习，其中我们学习一个特征嵌入，使得同一场景的视图映射到附近的点(用表示空间中的欧氏距离来度量)，而不同场景的视图映射到相距较远的点。本文的主要贡献：</p><ol><li>我们将对比学习应用于多视图场景，试图最大化同一场景不同视图表示之间的互信息。</li><li>随着视图数量的增加，我们学习到表示质量也在提高。</li></ol><h2 id="方法">方法</h2><p>我们的目标是学习在无监督情况下捕获多个感官视图之间共享信息的表示。</p><h3 id="在两个视图上的对比学习">在两个视图上的对比学习</h3><p>我们把那些来自联合分布的样本称为正样本，来自边际乘积样本称为负样本。</p><blockquote><p>从联合分布抽取正样本时，我们实际上实在选择那些在特征空间上与锚点样本接近的样本，这些样本反映了数据内在相似性，而边际分布的样本，则与锚点样本距离较远，代表了数据的差异性。对比学习中我们用正样本来学习样本相似性，负样本来区分不同样本差异性。</p></blockquote><p>我们学习了一个&quot;评论家&quot; (一个判别函数) hθ ( · )，该评论家被训练为对正对取得高值，对负对取得低值。我们训练下列函数来正确地从包含k个负样本的集合S = { x，y1，y2，…，yk }中选择单个正样本x。<img src="https://s2.loli.net/2024/03/08/AJ4ahEP1mUoLKyw.png" alt="image-20240308144209559"></p><p>对于这个判别函数的实现，我们先固定一个视图v1，为了提取v1和v2的紧凑潜在表示，我们使用两个编码器f θ 1 ( · )和f θ 2 ( · )，参数分别为θ 1和θ 2。<img src="https://s2.loli.net/2024/03/08/srMPpI7L4XQqlzG.png" alt="image-20240308145151578"></p><p>类似公式3，我们可以通过锚定v2m,得到类似公式。我们把它们加起来作为我们的双视图损失</p><p><img src="https://s2.loli.net/2024/03/08/SQTY14uk6NfLRF2.png" alt="image-20240308141137918"></p><h3 id="超过两个视图的对比学习">超过两个视图的对比学习</h3><p>我们给出了公式2更加普遍的形式，能够处理任意数量的视图。我们称之为&quot;核心观点&quot;和&quot;全图&quot;范式，它们在效率和效果之间提供了不同的权衡。这些公式如图所示。图中每个分区的数字表示该分区贡献的成对目标L( Vi、Vj)有多少。</p><img src="https://s2.loli.net/2024/03/08/8aPRCSVDXZoA4lr.png" alt="image-20240308151838265" style="zoom: 80%;" /><p>假设有M个视图集合V1，…，VM。&quot;核心视图&quot;的提法是我们想要优化的一个视图(如V1 )分开，通过优化一组成对目标的总和，在V1和彼此视图Vj，j &gt; 1之间建立成对表示：</p><p><img src="https://s2.loli.net/2024/03/08/Grh8BXZiH7zlKAv.png" alt="image-20240308152949512"></p><p>第二个&quot;全图&quot;范式，我们考虑所有的对( i , j)，i 6 = j，并在所有的对中建立( n 2 )个关系。通过涉及所有对，我们优化的目标函数是：<img src="https://s2.loli.net/2024/03/08/ATXtdOyWGkRisD4.png" alt="image-20240308153054662"></p><p>例如，在核心视图范式(如信息图中的0计数所示)中，V2与V3或V2与V4之间的互信息被完全忽略。全图形式的另一个好处是它可以以自然的方式处理缺失信息(例如,缺失的观点)。</p><h3 id="对比损失的实现">对比损失的实现</h3>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 多视图聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于图的多视图聚类</title>
      <link href="/2024/04/04/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/"/>
      <url>/2024/04/04/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1>基于图的多视图聚类</h1><h2 id="摘要">摘要</h2><p>基于多视图图聚类旨在<strong>为多视图数据提供聚类解决方案</strong>。然而，<strong>大多数现有方法没有充分考虑不同视图的权重，并且需要额外的聚类步骤来生成最终的聚类</strong>，他们通常还基于所有视图的固定图相似度矩阵来优化他们的目标。</p><p>基于图的多视图聚类（GMC）：将所有视图的数据图矩阵融合起来，生成一个统一的图矩阵，统一的图矩阵反过来改进了每个视图的数据图矩阵，也直接给出了最终的聚类。</p><p><strong>GMC的关键新颖之处</strong></p><ol><li>帮助每个视图图矩阵的学习和统一图矩阵的学习以相互强化的方式进行</li><li>一种新颖的多视图融合技术可以自动加权每个数据图矩阵以得出统一的图矩阵</li><li>没有引入调整参数的秩约束也被施加在统一矩阵的图拉普拉斯矩阵上，这有助于将数据点自然地划分为所需数量的集群</li><li>提出了一种交替迭代优化算法来优化目标函数</li></ol><h2 id="介绍">介绍</h2><blockquote><p>例如，同一条新闻可能由不同的新闻机构报道，一张图片可能由不同类型的特征编码，在网站上分享的一张图片可能有不同的文字描述。所有这些都被称为多视图数据，其中每个单独的视图构成一个学习任务，但每个视图也有其偏差。</p></blockquote><p>基于多视图图的聚类方法通常</p><ul><li>首先在所有视图的输入图中找到一个融合图</li><li>然后在该融合图上采用额外的聚类算法以产生最终的聚类</li></ul><p>尽管这些方法已经实现了最先进的性能，但它们仍然存在一些局限性</p><ol><li>在某些方法中没有考虑不同视图重要性的差异，例如 [5]。我们的方法通过自动生成的权重来处理差异</li><li>许多现有的方法需要一个额外的聚类步骤来在融合后产生最终的聚类，例如，[5]、[6]、[7]。我们的模型直接在融合中生成集群，无需额外的集群步骤</li><li>大多数当前的方法是单独构建每个视图的图，并在融合过程中保持构建的图固定，例如，[5]、[6]、[7]、[9]、[10]、[12]。我们的方法联合构建每个视图图和融合图。因此，两种施工工艺自然相辅相成。</li></ol><p>为什么我们需要解决这三个限制？原因如下</p><ul><li>首先，样本选择偏差[13]导致视图多样性，如果我们在某个领域中只选择特定类型的样本进行聚类，那么结果可能会缺乏对其他类型样本的代表性。这种样本选择偏差会导致视角的多样性不足</li><li>其次，额外的聚类步骤会带来额外的可能近似正确 (PAC) 界限 [14]，如果我们在聚类过程中增加额外的步骤，比如重复聚类或者调整参数，会导致PAC边界的扩大，PAC边界是一种用于衡量学习算法在有限样本下的错误概率的理论界限。边界的扩大意味着聚类算法可能会犯更多的错误或产生更大的误差。</li><li>第三，不同的相似性度量对多视图聚类质量有影响[15]，不同的相似度度量方法会导致不同的聚类结果</li></ul><p>在本文中，我们提出了一种新颖的多视图聚类模型，称为基于图的多视图聚类（GMC）</p><ul><li>GMC不仅可以自动对每个视图进行加权，融合后直接生成最终的聚类，无需执行任何额外的聚类步骤</li><li>而且可以共同构建每个视图的图和融合图，从而相互帮助，相互增强。</li></ul><p>我们的 GMC 的整体流程如图 1 所示</p><p><img src="https://s2.loli.net/2024/04/04/L1CluiyQKOYa9Mx.png" alt="image-20231124195738598"></p><p>具体而言</p><p>首先将每个视图的数据矩阵转换为从相似图矩阵生成的图矩阵。我们将此图矩阵称为相似性诱导图 (SIG) 矩阵<br>然后将所提出的融合方法应用于所有视图的 SIG 矩阵，以便从 SIG 矩阵中学习统一矩阵（即融合图矩阵）U。 U 的学习会自动考虑不同视图 (v) 的不同权重 (wv)。同时，学习到的统一矩阵 U 回去改进每个视图的 SIG 矩阵。还对统一矩阵的拉普拉斯矩阵 LU 施加秩约束，以约束统一矩阵中的连通分量数等于所需的簇数 c。<br>因此，我们的模型 GMC 对每个视图的 SIG 矩阵进行加权和改进，并同时生成统一矩阵和最终集群。</p><p>综上所述，本文有以下贡献：</p><p>动机：它研究了一种先进的多视图聚类范式，并为多视图数据提供了一种新的聚类解决方案。<br>模型：它提出了一种通用的基于图的多视图聚类方法来解决当前方法的上述局限性。 GMC自动对每个视图进行加权，联合学习每个视图的图和融合图，融合后直接生成最终的聚类。值得注意的是，每个视图图的学习和融合图的学习可以互相帮助。<br>算法：它提出了一种交替迭代优化算法来解决GMC问题，其中每个子问题都有一个最优解。<br>结果：实验结果表明，所提出的 GMC 方法比最先进的基线方法有相当大的改进。</p><h2 id="相关工作">相关工作</h2><p>&quot;基于图的多视图聚类&quot;是一种在数据上构建图并根据节点之间的相似性（即边）进行聚类的方法。而&quot;多视图谱聚类&quot;则是一种在数据上构建相似性图后，先寻找数据的低维嵌入表示，然后在这个表示上使用K-means算法来产生最终的聚类结果。因此，两者的区别在于多视图谱聚类首先找到了数据的低维嵌入表示再进行聚类，而基于图的多视图聚类直接在数据的图结构上进行聚类。</p><h2 id="基于图的多视图聚类">基于图的多视图聚类</h2><p>作为一个整体，GMC将每个视图的SIG矩阵的学习、所有视图的融合图矩阵的学习和聚类任务建模成一个单一的框架，自动为每个视图加权，共同生成每个视图的SIG矩阵和所有视图的融合图矩阵，并直接在融合图矩阵上产生聚类。</p><h3 id="相似性诱导图矩阵的构建">相似性诱导图矩阵的构建</h3><p>可以通过K邻近图方法将数据矩阵转化为相似度矩阵，我们通过稀疏表示法来构造SIG矩阵，问题建模如下：<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125141734885.png" alt="image-20231125141734885"></p><p>第二项是L1正则项。我们可以对其进行归一化，使得其变为常数，也等价于对矩阵S施加稀疏约束。所以问题1变成<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125142236694.png" alt="image-20231125142236694"></p><p>而公式2存在平凡解，即只有一个与xi最近的数据点的相似度为1，于是我们加了一个先验条件，问题2变成<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125142443647.png" alt="image-20231125142443647"></p><p>问题3的第二项存在一个解，即每个数据点到xi的相似度都是1/n。</p><h3 id="多数据图融合">多数据图融合</h3><p>我们通过SIG矩阵S1,…Sm得到融合图矩阵，可以求解下列优化问题得到：<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125144220237.png" alt="image-20231125144220237"></p><p>W是自动确定的权重矩阵，ui是融合图矩阵U的列向量，<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125151428416.png" alt="image-20231125151428416"></p><p>然后我们联合问题3和问题4得到下面问题<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125151516413.png" alt="image-20231125151516413"></p><p>可以看出，每个SIG矩阵S1，…，Sm和统一图矩阵U的学习耦合成一个联合问题。这样，两者的学习自然可以互相帮助。</p><h3 id="拉普拉斯秩约束的多视图聚类">拉普拉斯秩约束的多视图聚类</h3><p>该部分旨在解决最终的问题，即直接在统一的图矩阵U上产生聚类结果，而不需要额外的聚类算法或步骤，求出统一图矩阵的拉普拉斯矩阵。</p><blockquote><p>拉普拉斯矩阵LU的特征值0的重数r等于统一矩阵U的图中连通分量的个数。</p></blockquote><p>如果rank(LU)=n-c,那恰好好是图LU被分成c个簇的理想情况。那么问题9变成如下形式：<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125153409416.png" alt="image-20231125153409416"></p><p>如果<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125153912722.png" alt="image-20231125153912722">，则满足秩约束，而又根据定理我们知道<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125154009517.png" alt="image-20231125154009517"></p><p>将公式11带入10得到：<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125154404254.png" alt="image-20231125154404254"></p><p>其中，得到的统一图矩阵U恰好包含c个连通分支，将数据点划分为c个簇。在接下来的章节中，我们提出了一种新的算法来求解问题( 12 )，并用交替规则来优化其目标函数</p><h2 id="优化算法">优化算法</h2><p>我们使用交替优化算法来求解问题12</p><ol><li>固定w,U,F，更新S1,…Sm:则问题12 变成如下形式：<img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125155009670.png" alt="image-20231125155009670"></li></ol><p><img src="C:%5CUsers%5CAce%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231125161115091.png" alt="image-20231125161115091"></p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 多视图聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于对比预测的缺失视图聚类方法</title>
      <link href="/2024/03/26/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%AF%94%E9%A2%84%E6%B5%8B%E7%9A%84%E7%BC%BA%E5%A4%B1%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
      <url>/2024/03/26/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%AF%94%E9%A2%84%E6%B5%8B%E7%9A%84%E7%BC%BA%E5%A4%B1%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>多视图/多模态表示学习旨在从多视图/模态数据中学习有效的表示，以改进聚类、分类、检索等下游任务的性能。现有多视图表示学习方法的成功都显式或隐式地要求数据满足视图“完备性”和“一致性”假设。其中“完备性”假设要求每一实例在所有的视图中均需存在，即要求数据是“完整的”；“一致性”假设则要求每一实例在所有的视图中均存在正确的对应关系，即要求数据是跨视图“对齐的”。当数据不满足任一假设时，大多数多视图学习方法，特别在无监督条件下，都难以学习到有效的表示。</p><p><strong>信息量度量的是一个具体事件发生了所带来的信息，而熵则是在结果出来之前对可能产生的信息量的期望——考虑该随机变量的所有可能取值，即所有可能发生事件所带来的信息量的期望</strong></p><blockquote><p>互信息是信息论中用以评价两个随机变量之间的依赖程度的一个度量。</p><p>举个例子：x=今天下雨与y=今天阴天，显然在已知y的情况下, 发生x的概率会更大</p><p>熵H ( X )表示X 的不确定度（不确定度越大，信息量越大）</p><p>联合熵H ( X , Y ) 表示X 和Y一起发生时，产生的信息量。</p><p>条件熵H ( X ∣ Y ) 表示在Y发生的前提下，X 发生新带来的信息量。</p><p>最小化条件熵可以增加数据的可恢复性，因为条件熵反映了在给定一个变量的情况下，另外一个变量的不确定性，如果条件熵越小说明给定变量对另外一个变量的影响越大，也就是另一个变量的信息可以容易从给定变量的信息恢复出来。</p></blockquote><p>其次，我们的方法是专门为处理缺失数据而设计的，而现有的对比学习工作忽略了这一实际问题。第三，虽然现有的对比学习研究表明可以通过最大化不同增强的互信息来学习一致性，但它们忽略了不一致性学习。在统一的信息论框架下，我们证明了不一致性学习可以用条件熵来定义，并且通过最小化不一致性可以恢复缺失数据。</p><h2 id="方法">方法</h2><p>在本节中，我们提出了一种深度多视图聚类方法，命名为COMPlete muLti-view clustEring through con TrastivE pReuation (完成符)，用于学习一组不完整多视图样本的表示。如图所示，完成符由三个联合学习目标组成，即视图内重构、跨视图对比学习和跨视图双预测。为了清晰起见，我们将首先介绍所提出的损失函数，然后详细说明每个目标。</p><img src="https://s2.loli.net/2024/03/08/E15ek89UoXF7Sv3.png" alt="image-20240308170254588" style="zoom:80%;" /><h3 id="目标函数">目标函数</h3><p>以双视图数据集为例，提出下列目标函数。</p><img src="https://s2.loli.net/2024/03/08/sSLbPiWwKJhBdmj.png" alt="image-20240308171447278" style="zoom:80%;" /><p>其中Lcl、Lpre和Lrec分别为跨视角对比损失、双预测损失和视角内重构损失。参数λ 1和λ 2分别为Lpre和Lrec上的平衡因子。</p><h3 id="视图内重构">视图内重构</h3><p>对于每个视图，我们使用一个自编码器，最小化下列函数来学习潜在表示</p><img src="https://s2.loli.net/2024/03/09/JBlCiP7n19V2EoG.png" alt="image-20240309150348774" style="zoom: 67%;" /><p>f是编码器，g是解码器，其中潜在表示Z=fX</p><h3 id="跨视图对比">跨视图对比</h3><p>在Lrec参数化的潜在空间中，我们进行对比学习来学习不同视图之间共享的共同表示。本文通过最大化互信息的下界学习表示Z1和Z2，直接最大化不同视图表示之间的互信息。在数学上表示如下：</p><img src="https://s2.loli.net/2024/03/09/5N4KZABbGmjSlVU.png" alt="image-20240309151401913" style="zoom:67%;" /><p>I表示互信息，H表示信息熵，一方面，从信息论的角度来看，信息熵是一个事件所传递的平均信息量[ 3 ]。因此，一个较大的熵H ( Zi )表示一个信息量更大的表示Zi。另一方面，H ( Z1 )和H ( Z2 )的最大化将避免将所有样本分配到同一簇的平凡解</p><p>为了构造I( Zt1、Zt2)，我们首先定义了变量z和z′的联合概率分布P( z , z′)。</p><img src="https://s2.loli.net/2024/03/09/RyBkitfU7aqVLsz.png" alt="image-20240309152748863" style="zoom:67%;" /><p>令Pd和P′d表示边缘概率分布P( z = d)和P( z′= d′)，它们可以通过对联合概率分布矩阵P的第d行和第d′列求和得到，Pdd′为P的第d行第d′列元素</p><h3 id="实例级对比预测">实例级对比预测</h3><p>在一个由神经网络参数化的潜在空间中，通过最小化熵H 条件( Zi | Zj )来预测另一个视图的特定表示。</p><p>对于给定的双视图数据集，我们进一步有</p><img src="https://s2.loli.net/2024/03/09/yw1A5WVI2d9cBZg.png" alt="image-20240309153817275" style="zoom:67%;" /><p>G ( j ) ( · )可以是一个参数化模型，它将Zj映射到Zi。模型收敛后，通过上述对偶映射很容易从~ Zj中预测缺失表示~ Zi，即<img src="https://s2.loli.net/2024/03/09/76nfpHhKIuxocyr.png" alt="image-20240309154051358" style="zoom:67%;" />，Zj表示~ Xj的表示。</p><h3 id="两个以上视图的对比预测">两个以上视图的对比预测</h3><p>通过对偶对比预测来解决这个问题有两种通用的方法，即基于核心视图的方法( DCP-CV )和基于完全图的方法( DCP-CG )。</p><p><img src="https://s2.loli.net/2024/03/26/m2keBxfC6zvdXUQ.png" alt="image-20240326154729929"></p><blockquote><p>对两个以上视图进行对比预测。实心圆和点状圆分别表示可用视图和缺失视图。线条表示用Licl和Lpre进行训练，箭头表示丢失视图的恢复。</p></blockquote><ul><li><strong>DCP-CV</strong>：一个具有V个视图的多视图数据集，我们选定一个核心视图X1，然后X1与其他视图Xj进行对比预测。</li></ul><p><img src="https://s2.loli.net/2024/03/26/JkIDq81U3eM75tu.png" alt="image-20240326152729272"></p><p>其中<img src="https://s2.loli.net/2024/03/26/KNX7L8EcjD61t95.png" alt="image-20240326152831396">，而Lccl是类别级别对比预测，是利用数据标签来增强数据的可分性。对于无监督学习，这一项可以去除。</p><ul><li><strong>DCP - CG</strong>：对所有可能的视图对进行实例级的对比学习和对偶预测，如图所示。在形式上，</li></ul><p><img src="https://s2.loli.net/2024/03/26/ZisnPFN8EUrTRze.png" alt="image-20240326154508121"></p><p>虽然DCP - CV和DCP - CG都能够学习到充分和最小的表示，但我们推荐后者，原因如下。一方面为了一致性学习，DCP - CG将捕获更多的信息，因为在学习阶段包含并利用了所有的视图对。</p><p>具体来说，DCP - CG试图最大化视图间的互信息V(V-1)/2次，而DCP - CV只最大化V-1次，另一方面，DCP - CG在执行数据恢复时比DCP-CV表现出更强的鲁棒性。</p><p>下面给出DCP - CG鲁棒性更强的理论解释。</p><ol><li>如图3 ( b )中列所示，DCP - CG可以很容易地通过平均其他可用视图的预测来恢复丢失的视图。</li><li>如图3 ( a )右列所示，DCP-CV可能会遇到误差累积问题。具体来说，当X1和X3都缺失时，首先需要恢复核心视图X1，然后恢复X3。</li><li>DCP - CV需要选择一个重要的视图作为核心视图，在先验知识不可得的情况下，这个核心视图是困难的。在我们的实现中，为了简单起见，我们随机选择一个视图作为核心视图。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 多视图聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不完全信息下的鲁棒多视图聚类</title>
      <link href="/2024/03/04/%E4%B8%8D%E5%AE%8C%E5%85%A8%E4%BF%A1%E6%81%AF%E4%B8%8B%E7%9A%84%E9%B2%81%E6%A3%92%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/"/>
      <url>/2024/03/04/%E4%B8%8D%E5%AE%8C%E5%85%A8%E4%BF%A1%E6%81%AF%E4%B8%8B%E7%9A%84%E9%B2%81%E6%A3%92%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction">Introduction</h2><p><strong>存在的问题</strong>：多视图聚类，目的是从多视图数据中学习到通用的特征表达，然后在这些特征表达上进行聚类——MvC依赖于两个假设：视图一致性、实例完全性——在数据收集和数据传输的过程中，常常会出现数据丢失导致上述两个假设不成立——因此出现了所谓的部分视图未对齐问题（PVP）和部分样本缺失问题（PSP）,与PSP问题不同的是，PVP问题很少收到关注.</p><p><strong>提出的框架</strong>：对于每一个样本，目标框架的目的是在类别层级建立跨视图对应关系。本文将这两个解决方法分别记为类别级对齐（CA）和类别级归责（,CI），两者之间的不同之处在于，CA的目标是识别一个对等物，而CI的目标是识别多个对等物。建立相关性之后，CA可以通过将样本<img src="https://latex.csdn.net/eq?x_i%5E%7B%281%29%7D" alt="x_i^{(1)}">和其对应的样本<img src="https://latex.csdn.net/eq?x_j%5E%7B%282%29%7D" alt="x_j^{(2)}">对齐来解决PVP问题；相似的，CI可以通过<img src="https://latex.csdn.net/eq?x_i%5E%7B%282%29%7D" alt="x_i^{(2)}">的<img src="https://latex.csdn.net/eq?k" alt="k">个对应样本恢复缺失的样本<img src="https://latex.csdn.net/eq?%5Chat%7Bx%7D_i%5E%7B%281%29%7D" alt="\hat{x}_i^{(1)}">解决PSP问题。</p><img src="https://s2.loli.net/2024/03/23/4Nph9eqRMamwD2x.png" alt="image-20240323201653339" style="zoom:67%;" /><p><strong>提出的方法</strong>：基于上述观察，本文提出了一个同时解决PVP和PSP问题的方法，即robuSt mUlti-view clusteRing with incomplEte information (SURE)，目标是学习类别级的相似性和建立跨视图的相关性，通过一个噪音鲁棒的对比学习算法。SURE将对齐的视图当做正样本对，然后在同一个样本的不同视图中随机构建负样本对。但是，这种负样本的构建方法中，会错误的将同一类下的样本视为负样本，即假阴性样本对。为了解决假阴性的问题提出了噪音鲁棒的对比损失</p><blockquote><p>对比学习是一种无监督的学习方式,它通过比较数据的相似性和不相似性来学习特征表示。对比学习的关键是选取合适的正样本对和负样本对。在本方法中我们把有完整信息的样本，即对齐、可观测到的样本当作正样本对，我们跨视图随机构建负样本对，显然这样可能会把同类样本当作阴性，我们把这称作假阴性。为了消除这个问题，提出了一种噪声鲁棒损失</p></blockquote><h2 id="相关工作">相关工作</h2><h3 id="多视图聚类">多视图聚类</h3><p>一方面，SURE可以同时处理PVP和PSP，而现有的工作只能处理其中的一种或两种。另一方面，SURE旨在实现类别级别而非实例级别的视图对齐和数据恢复。类别级别的对齐使得SURE具有更高的聚类可达性和可扩展性，并在实验中得到了验证。更具体地说，对于两个跨视图样本，实例和类别层面的对齐概率分别为1 / N和1 / K，N和K分别表示实例和类别的个数，一般情况下K 远小于N。</p><h3 id="对比学习">对比学习</h3><p>大多数对比学习方法首先通过对原始数据进行一系列增强来在实例级别构建样本对。同一实例的增强样本被定义为正样本，而其他样本被视为负样本。利用增强数据，提出了各种损失，通过最大化正例的相似性同时最小化负例的相似性来学习表示。</p><p>本工作与现有的对比学习方法之间的主要区别如下。首先，我们的 SURE 配备了一种新颖的对比损失，对于假阴性具有很强的鲁棒性，而大多数这些方法无法处理这个问题。</p><h3 id="使用嘈杂的标签学习">使用嘈杂的标签学习</h3><p>我们考虑一种新颖的噪声标签范式，即对应关系而不是类别注释是不正确的。此外，SURE 被提出来聚类多视图数据，而几乎所有应付inoisy标签的方法都是为了分类而提出的。</p><h2 id="论文方法">论文方法</h2><h3 id="问题定义">问题定义</h3><ul><li><p>部分视图不对齐问题（PVP）：当满足下列公式的时候，数据集是没对齐的。</p><img src="https://s2.loli.net/2024/03/23/9m4OJQ8A3vKeV6z.png" alt="image-20240323210109757" style="zoom:67%;" /><p>I（a，b)是一个指示函数，如果a，b属于同一实例，则为1。V表示视图数量，W表示有PVP或PSP问题的数据集。</p></li><li><p>部分样本缺失问题（PSP）：当满足下列公式的时候，数据集是样本缺失的。</p><img src="https://s2.loli.net/2024/03/23/YPo63sfAv2gaiLt.png" alt="image-20240323211436337" style="zoom:67%;" /><p>| . |是非缺失样本数量</p><p>为了探索PVP和PSP的统一解决方案，我们通过建立交叉视图对应关系，提出了一个类别级别的识别框架。</p></li><li><p>类别层面的识别：旨在找到一个样本在其他视图的同类项。</p></li></ul><img src="https://s2.loli.net/2024/03/23/jWXYVqRwQ6JnNZi.png" alt="image-20240323211854686" style="zoom:67%;" /><p>其中C(a,b)是指示函数，如果a，b是同一类别，则为1。K为每个类别实例数</p><p>根据这个公式，我们可以建立对应的类别对应关系，样本可以与对应的来对齐，类似的，一个缺失样本Xi能够通过该样本所在视图的对等点（对等点通过Xj所建立的对应关系来确定）被恢复。</p><p>SURE，它由三个模块组成，即配对构建、噪声鲁棒优化和通用学习。为了不失一般性，我们取V=2，如图2所示，成对构造模块使用( s ( 1 ) i，s ( 2 ) i )作为正对，随机选择跨视图样本组成负对( s ( 1 ) i，s ( 2 ) j )。</p><img src="https://s2.loli.net/2024/03/24/rOTBzeMiJ41sYuA.png" alt="image-20240324155301541" style="zoom:67%;" /><blockquote><p>图2 .提出的SURE的流程：它由三个模块组成，即成对构造、噪声鲁棒优化和通用学习。</p><p>对于成对构造，SURE利用已知的对应关系构造正对，并在完全对齐且完备的数据{ S ( v ) } 2v = 1上随机采样形成负对。这样的随机抽样策略不可避免地会引入一些假阴性对( FNPs )，这些FNPs应被视为阳性。</p><p>为了防止这些FNPs主导网络更新，SURE采用了两阶段优化方案。具体来说，( a )对比学习：首先用香草对比损失对网络进行预热，直到否定词的平均距离大于自适应间隔m。然后，SURE切换到( b )噪声鲁棒的对比学习：它将通过减少(见B点)甚至逆转其梯度(见A点)来减轻甚至消除FNPs的影响。在( a )和( b )中，箭头的方向和长度分别表示梯度的方向和大小。</p><p>此外，为了保留视图特有的信息，SURE通过使用公共表示来重构输入来进行通用学习。</p></blockquote><p>随机取样不可避免地引入噪声标签(即,假阴性对)，为了减轻甚至消除这些特殊噪声标签的影响，我们设计了一个具有噪声鲁棒性的优化模块，SURE的整体损失函数为如下：</p><img src="https://s2.loli.net/2024/03/24/RKfSTEMQxOFyGto.png" alt="image-20240324154854867" style="zoom:67%;" /><p>第一项是噪声鲁棒性优化模块，第二项是通用学习模块</p><h3 id="噪声-鲁棒对比学习">噪声-鲁棒对比学习</h3><p>为了减轻甚至消除假阴性对的影响，我们提出了以下噪声鲁棒的对比损失，即</p><img src="https://s2.loli.net/2024/03/24/Z2dTuSAnQwRx7be.png" alt="image-20240324161923014" style="zoom:67%;" /><p>其中N表示对数，如果为正对则Y=1，否则为0，显然，Lpos i和Lneg i分别对正对和负对有作用。</p><p>给定一个正对，SURE的目标是通过最小化它在隐空间中的距离</p><img src="https://s2.loli.net/2024/03/24/B4veMw9KaLWRdPz.png" alt="image-20240324162651839" style="zoom:67%;" /><p>f表示视图编码器，</p><p>为了包含对FNPs的鲁棒性，我们提出了下面的噪声鲁棒性对比项，即，</p><p><img src="https://s2.loli.net/2024/03/24/Cg14hkUdoxiXPwc.png" alt="image-20240324200838371"></p><p><img src="https://s2.loli.net/2024/03/24/AKzHNPkeWTG2vju.png" alt="image-20240324202151595"></p><p>Np和Nn分别表示正负对的个数.值得注意的是，m只在网络初始化后计算一次，并在以后的训练过程中被固定。</p><blockquote><p><strong>理论1：本文提出的噪音鲁棒项不是单调的</strong></p><p><strong>理论2：优化逆转。噪音鲁棒项的梯度方向，比起简单的损失，在<img src="https://latex.csdn.net/eq?0%3Cd%3Cm/3" alt="0&lt;d&lt;m/3">的区间中是相反的。</strong></p><p><strong>理论3：慢优化。噪音鲁棒项的梯度方向，比起简单的损失，在<img src="https://latex.csdn.net/eq?m/3%3Cd%3Cm" alt="m/3&lt;d&lt;m">的区间中梯度下降速度更慢。</strong></p></blockquote><p>对于距离在( 0 , m / 3)中的任意FNPs，所提出的SURE可以通过反转它们的梯度来正确地减小它们的距离。对于距离在( m / 3 , m)中的任意FNPs，SURE可以减少不必要的距离增量，从而阻止网络拟合FNPs。</p><p>在预热阶段，我们的SURE首先使用香草项对网络进行优化直到负对的平均距离大于m，香草项如下：<img src="https://s2.loli.net/2024/03/24/ghUi37RawGd1AI2.png" alt="image-20240324201833560"></p><p>因为TNPs比FNPs拟合速度更快。因此，大量的TNPs会有d &gt; m的距离，而大部分的FNPs会落入d &lt; m的区域。这表明我们的噪声鲁棒性损失主要影响FNPs而不是TNPs。在第二个优化阶段使用了噪声鲁棒性对比损失(即, Eq . 5 )。</p><p>在这个阶段，由于大多数FNPs位于0 &lt; d &lt; m / 3或m / 3 &lt; d &lt; m的区域内，它们的距离要么减小，要么缓慢增加，因此，噪声标签的影响被消除或减轻。值得注意的是，第二阶段对TNPs的影响可以忽略不计，因为在热身阶段之后，TNPs的大部分距离都大于m。</p><h3 id="充分的通用学习">充分的通用学习</h3><p>由于对比学习范式可能过于强调观点之间的一致性，我们进一步提出了一个通用的学习模块，以鼓励共同表征保持信息的充分性。<strong>多视图表示的充分性。对于第<img src="https://latex.csdn.net/eq?i" alt="i">个样本<img src="https://latex.csdn.net/eq?s_i%5E%7B%28v%29%7D" alt="s_i^{(v)}">，<img src="https://latex.csdn.net/eq?h_i%5E%7B%28v%29%7D" alt="h_i^{(v)}">记为其具体视图的特征表达，<img src="https://latex.csdn.net/eq?h_i" alt="h_i">记为其的通用特征表达。当<img src="https://latex.csdn.net/eq?%5Cforall%20v%20%5Cin%5B1%2C%20V%5D" alt="\forall v \in[1, V]">的时候，<img src="https://latex.csdn.net/eq?h_i" alt="h_i">是充分的，<img src="https://latex.csdn.net/eq?s_i%5E%7B%28v%29%7D" alt="s_i^{(v)}">是<img src="https://latex.csdn.net/eq?h_i" alt="h_i">通过映射<img src="https://latex.csdn.net/eq?%5Cphi%28%5Ccdot%29" alt="\phi(\cdot)">的重构结果</strong>。相应地，提出以下通用损失来保持学习到的表示的充分性，即：<img src="https://s2.loli.net/2024/03/24/kVTuq865jydSA4z.png" alt="image-20240324203538086"></p><h3 id="类别-级别对齐和补全">类别-级别对齐和补全</h3><p>据建立的跨视图对应关系，我们在推理阶段设计了两种策略来处理PVP和PSP。简而言之，提出了类别级对齐策略来重新对齐跨视图样本，并使用填补策略来恢复缺失样本。</p><p>类别对齐（CA)：对于视图v1中的每个样本x ( v1 ) i，CA将其与每个视图v2中的对应样本x ( v2 ) j进行重新排列，使得：<img src="https://s2.loli.net/2024/03/24/tc4eTOZGuikUhEp.png" alt="image-20240324205238689"></p><p>类别级别补充(CI):CI将缺失的样本[ x ( v1 ) i ]用它在同一视图中的同伴[ x ( v1 ) j ]的加权和来填补，即<img src="https://s2.loli.net/2024/03/24/OvAbFpDkSKQqg8c.png" alt="image-20240324205443293"></p><p>同伴j可以通过下列公式识别<img src="https://s2.loli.net/2024/03/24/ECORI4yVFBZPj18.png" alt="image-20240324210742285"></p><h2 id="算法总结">算法总结</h2><p>输入：一个双视图数据集X，大小为Nx，非缺陷部分记为S，大小为</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 多视图聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis(四)多对一处理和一对多处理</title>
      <link href="/2022/02/12/Mybatis-%E5%9B%9B-%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%A4%84%E7%90%86%E5%92%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%84%E7%90%86/"/>
      <url>/2022/02/12/Mybatis-%E5%9B%9B-%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%A4%84%E7%90%86%E5%92%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Lombok">Lombok</h2><p>使用步骤：</p><ol><li><p>在IDEA中安装Lombok插件！</p></li><li><p>在项目中导入lombok的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在实体类上加注解即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>：无参构造，get、set、tostring、hashcode，equals</span><br><span class="line"><span class="meta">@AllArgsConstructor</span>：使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数</span><br><span class="line"><span class="meta">@NoArgsConstructor</span>：使用后创建无参构造函数</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="多对一处理">多对一处理</h2><ul><li>多个学生，对应一个老师</li><li>对于学生这边而言， <strong>关联</strong> 多个学生，关联一个老师 【多对一】</li><li>对于老师而言， <strong>集合</strong> 一个老师，有很多学生 【一对多】</li></ul><h3 id="按照查询嵌套处理">按照查询嵌套处理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    思路:</span></span><br><span class="line"><span class="comment">        1. 查询所有的学生信息</span></span><br><span class="line"><span class="comment">        2. 根据查询出来的学生的tid，寻找对应的老师！  子查询</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复杂的属性，我们需要单独处理 对象： association 集合： collection --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    select * from teacher where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="按照结果嵌套处理">按照结果嵌套处理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--按照结果嵌套处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher2&quot;</span>&gt;</span></span><br><span class="line">    select s.id sid,s.name sname,t.name tname</span><br><span class="line">    from student s,teacher t</span><br><span class="line">    where s.tid = t.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="一对多处理">一对多处理</h2><p>比如：一个老师拥有多个学生！</p><p>对于老师而言，就是一对多的关系!</p><h3 id="按照查询嵌套处理-2">按照查询嵌套处理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent2&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.teacher where id = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.student where tid = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="按照结果嵌套处理-2">按照结果嵌套处理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--按结果嵌套查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">    select s.id sid, s.name sname, t.name tname,t.id tid</span><br><span class="line">    from student s,teacher t</span><br><span class="line">    where s.tid = t.id and t.id = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复杂的属性，我们需要单独处理 对象： association 集合： collection</span></span><br><span class="line"><span class="comment">    javaType=&quot;&quot; 指定属性的类型！</span></span><br><span class="line"><span class="comment">    集合中的泛型信息，我们使用ofType获取</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="小结">小结</h3><ol><li>关联 - association 【多对一】</li><li>集合 - collection 【一对多】</li><li>javaType &amp; ofType<ol><li>JavaType 用来指定实体类中属性的类型</li><li>ofType 用来指定映射到List或者集合中的 pojo类型，泛型中的约束类型！</li></ol></li></ol><p>注意点：</p><ul><li>保证SQL的可读性，尽量保证通俗易懂</li><li>注意一对多和多对一中，属性名和字段的问题！</li><li>如果问题不好排查错误，可以使用日志 ， 建议使用 Log4j</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis(三)分页和注解开发</title>
      <link href="/2022/02/12/Mybatis-%E4%B8%89-%E5%88%86%E9%A1%B5%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
      <url>/2022/02/12/Mybatis-%E4%B8%89-%E5%88%86%E9%A1%B5%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="分页">分页</h2><h3 id="使用Limit分页">使用Limit分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit startIndex,pageSize;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">3</span>;  #[<span class="number">0</span>,n]</span><br></pre></td></tr></table></figure><p>使用Mybatis实现分页，核心SQL</p><ol><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLimit</span><span class="params">(Map&lt;String,Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--//分页--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLimit&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from  mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="注解开发">注解开发</h2><h3 id="面向接口编程">面向接口编程</h3><p>大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程</p><p><strong>根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好</strong></p><p>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；</p><p>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</p><p><strong>关于接口的理解</strong></p><ul><li>接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。</li><li>接口的本身反映了系统设计人员对系统的抽象理解。</li><li>接口应有两类：<ul><li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；</li><li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</li></ul></li><li>一个体有可能有多个抽象面。抽象体与抽象面是有区别的。</li></ul><p><strong>三个面向区别</strong></p><ul><li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .</li><li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .</li><li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构</li></ul><h3 id="使用注解开发">使用注解开发</h3><ol><li><p>注解在接口上实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>需要再核心配置文件中绑定接口！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--绑定接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p>本质：反射机制实现</p><p>底层：动态代理！</p><p><img src="/img/pg/1569898830704.png" alt="1569898830704"></p><p><strong>Mybatis详细的执行流程！</strong></p><p><img src="/img/pg/Temp.png" alt="1569898830704"></p><h3 id="CRUD">CRUD</h3><p>我们可以在工具类创建的时候实现自动提交事务！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession  <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写接口，增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法存在多个参数，所有的参数前面必须加上 @Param(&quot;id&quot;)注解</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@Param(&quot;uid&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><p>【注意：我们必须要讲接口注册绑定到我们的核心配置文件中！】</p><p><strong>关于@Param() 注解</strong></p><ul><li>基本类型的参数或者String类型，需要加上</li><li>引用类型不需要加</li><li>如果只有一个基本类型的话，可以忽略，但是建议大家都加上！</li><li>我们在SQL中引用的就是我们这里的 @Param() 中设定的属性名！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis（二）CRUD和配置文件解析</title>
      <link href="/2022/01/26/MyBatis%EF%BC%88%E4%BA%8C%EF%BC%89CRUD%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/01/26/MyBatis%EF%BC%88%E4%BA%8C%EF%BC%89CRUD%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="CRUD">CRUD</h2><h3 id="namespace">namespace</h3><p>namespace中的包名要和 Dao/mapper 接口的包名一致！</p><h3 id="select">select</h3><p>选择，查询语句;</p><ul><li>id : 就是对应的namespace中的方法名；</li><li>resultType：Sql语句执行的返回值！</li><li>parameterType ： 参数类型！</li></ul><ol><li><p>编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据ID查询用户</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>编写对应的mapper中的sql语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Insert">Insert</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对象中的属性，可以直接取出来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="keyword">int</span> res = mapper.addUser(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">&quot;zhiyuan&quot;</span>, <span class="string">&quot;212313&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update">update</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125;  where id = #&#123;id&#125; ;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Delete">Delete</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li><p>增删改需要提交事务！</p><p>sqlSession.commit();</p></li></ul><h3 id="分析错误">分析错误</h3><ul><li>标签不要匹配错</li><li>resource 绑定mapper，需要使用路径！</li><li>程序配置文件必须符合规范！</li><li>NullPointerException，没有注册到资源!</li><li>输出的xml文件中存在中文乱码问题！</li><li>maven资源没有导出问题！</li></ul><h3 id="万能Map">万能Map</h3><p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//万能的Map</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    用map集合的方式插入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id,name,pwd) values (#&#123;userid&#125;,#&#123;username&#125;,#&#123;passWord&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用map的形式插入数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userid&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&quot;passWord&quot;</span>,<span class="string">&quot;2222333&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;map&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = mapper.addUser2(map);</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map传递参数，直接在sql中取出key即可！ 【parameterType=“map”】</p><p>对象传递参数，直接在sql中取对象的属性即可！【parameterType=“Object”】</p><p>只有一个基本类型参数的情况下，可以直接在sql中取到！</p><p>多个参数用Map，<strong>或者注解！</strong></p><h3 id="思考题">思考题</h3><p>模糊查询怎么写？</p><p>有两种方式</p><ul><li>Java代码执行的时候，传递通配符 % %</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;%李%&quot;</span>);</span><br></pre></td></tr></table></figure><p>这是我们指定查询<code>&quot;%李%&quot;</code>，如果放个参数获取，这种方式则不能避免sql注入问题</p><ul><li>在sql拼接中使用通配符！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br></pre></td></tr></table></figure><p>推荐使用这种方法</p><hr><h2 id="配置解析">配置解析</h2><h3 id="1、核心配置文件">1、核心配置文件</h3><ul><li><p>mybatis-config.xml</p></li><li><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">properties（属性）</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）</span><br></pre></td></tr></table></figure></li></ul><h3 id="环境配置（environments）">环境配置（environments）</h3><p>MyBatis 可以配置成适应多种环境</p><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p><p>如果要想再连接其它数据库，则需要重新再写个MybatisUtils工具类</p><p>学会使用配置多套运行环境！</p><p>Mybatis默认的事务管理器就是 JDBC ， 连接池 ： POOLED</p><h3 id="属性（properties）">属性（properties）</h3><p>我们可以通过properties属性来实现引用配置文件</p><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</p><p><img src="/img/pg/1569656528134.png" alt="1569656528134"></p><p>编写一个配置文件db.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>在核心配置文件中映入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11111&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以直接引入外部文件</li><li>可以在其中增加一些属性配置</li><li>如果两个文件有同一个字段，优先使用外部配置文件的！</li></ul><h3 id="类型别名（typeAliases）">类型别名（typeAliases）</h3><ul><li>类型别名是为 Java 类型设置一个短的名字。‘</li><li>存在的意义仅在于用来减少类完全限定名的冗余。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以给实体类起别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><p>扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以给实体类起别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.oddfar.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实体类比较少的时候，使用第一种方式。</p><p>如果实体类十分多，建议使用第二种。</p><p>第一种可以自定义别名，第二种则不行（别名为文件名），如果非要改，需要在实体上增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="设置">设置</h3><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p><p><img src="/img/pg/1569657659080.png" alt="1569657659080"></p><p><img src="../img/pg/1569657672791.png" alt="1569657672791"></p><h3 id="其他配置">其他配置</h3><ul><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）(opens new window)</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）(opens new window)</a></li><li>plugins插件<ul><li>mybatis-generator-core</li><li>mybatis-plus</li><li>通用mapper</li></ul></li></ul><h3 id="映射器（mappers）">映射器（mappers）</h3><p>MapperRegistry：注册绑定我们的Mapper文件；</p><p>方式一： 【推荐使用】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/oddfar/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：使用class文件绑定注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.oddfar.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>接口和他的Mapper配置文件必须同名！</li><li>接口和他的Mapper配置文件必须在同一个包下！</li></ul><p>方式三：使用扫描包进行注入绑定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.oddfar.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>接口和他的Mapper配置文件必须同名！</li><li>接口和他的Mapper配置文件必须在同一个包下！</li></ul><p>练习时间：</p><ul><li>将数据库配置文件外部引入</li><li>实体类别名</li><li>保证UserMapper 接口 和 UserMapper .xml 改为一致！并且放在同一个包下！</li></ul><h3 id="生命周期和作用域">生命周期和作用域</h3><p><img src="/img/pg/1569660357745.png" alt="1569660357745"></p><p>生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p><p><strong>SqlSessionFactoryBuilder：</strong></p><ul><li>一旦创建了 SqlSessionFactory，就不再需要它了</li><li>局部变量</li></ul><p><strong>SqlSessionFactory：</strong></p><ul><li>说白了就是可以想象为 ：数据库连接池</li><li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例。</strong></li><li>因此 SqlSessionFactory 的最佳作用域是应用作用域。</li><li>最简单的就是使用<strong>单例模式</strong>或者静态单例模式。</li></ul><p><strong>SqlSession</strong></p><ul><li>连接到连接池的一个请求！</li><li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。</li><li>用完之后需要赶紧关闭，否则资源被占用！</li></ul><p><img src="/img/pg/1569660737088.png" alt="1569660737088"></p><p>这里面的每一个Mapper，就代表一个具体的业务！</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis（一）入门</title>
      <link href="/2022/01/17/Mybatis%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8/"/>
      <url>/2022/01/17/Mybatis%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><h3 id="什么是Mybatis">什么是Mybatis</h3><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong></li><li>它支持定制化 SQL、存储过程以及高级映射。</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li><li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li><li>MyBatis 本是<a href="https://baike.baidu.com/item/apache/6265">apache (opens new window)</a>的一个开源项目<a href="https://baike.baidu.com/item/iBatis">iBatis (opens new window)</a>, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。</li><li>2013年11月迁移到Github。</li></ul><p>如何获得Mybatis？</p><ul><li><p>maven仓库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Github ： <a href="https://github.com/mybatis/mybatis-3/releases">https://github.com/mybatis/mybatis-3/releases</a></p></li><li><p>中文文档：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p></li></ul><h3 id="什么是持久化">什么是持久化</h3><p>数据持久化</p><ul><li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li><li>内存：<strong>断电即失</strong></li><li>数据库(Jdbc)，io文件持久化。</li><li>生活：冷藏. 罐头。</li></ul><p><strong>为什么需要需要持久化？</strong></p><ul><li>有一些对象，不能让他丢掉。</li><li>内存太贵了</li></ul><h3 id="持久层">持久层</h3><p>Dao层，Service层，Controller层….</p><ul><li>完成持久化工作的代码块</li><li>层界限十分明显。</li></ul><h3 id="为甚么需要Mybatis">为甚么需要Mybatis</h3><ul><li>帮助程序猿将数据存入到数据库中。</li><li>方便</li><li>传统的JDBC代码太复杂了。简化。框架。自动化。</li><li>不用Mybatis也可以。更容易上手。</li><li>优点：<ul><li>简单易学</li><li>灵活</li><li>sql和代码的分离，提高了可维护性。</li><li>提供映射标签，支持对象与数据库的orm字段关系映射</li><li>提供对象关系映射标签，支持对象关系组建维护</li><li>提供xml标签，支持编写动态sql。</li></ul></li></ul><h2 id="第一个Mybatis程序">第一个Mybatis程序</h2><p>创建模块<code>mybatis-01</code> 代码文件如下：</p><p><img src="/img/pg/image-20210412205636100.png" alt="image-20210412205636100"></p><p>思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！</p><h3 id="搭建环境">搭建环境</h3><p>搭建数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `mybatis`;</span><br><span class="line"></span><br><span class="line">USE `mybatis`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user`(</span><br><span class="line">  `id` INT(<span class="number">20</span>) NOT NULL PRIMARY KEY,</span><br><span class="line">  `name` VARCHAR(<span class="number">30</span>) DEFAULT NULL,</span><br><span class="line">  `pwd` VARCHAR(<span class="number">30</span>) DEFAULT NULL</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `user`(`id`,`name`,`pwd`) VALUES </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;123890&#x27;</span>)</span><br></pre></td></tr></table></figure><p>新建项目</p><ol><li><p>新建一个普通的maven项目</p></li><li><p>删除src目录</p></li><li><p>导入maven依赖及静态文件导出配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>注：若mysql驱动版本为8.x版本，需要配置mysql时区，还需更改驱动为<code>com.mysql.cj.jdbc.Driver</code></p><h3 id="创建一个模块">创建一个模块</h3><ul><li><p>编写mybatis的核心配置文件</p><p>在<code>resources</code>下添加<code>mybatis-config.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要添加中文注释，把第一行的<code>encoding=&quot;UTF-8&quot;</code>改成<code>encoding=&quot;utf8&quot;</code></p></li><li><p>编写mybatis工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用Mybatis第一步：获取sqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。</span></span><br><span class="line"><span class="comment">     * SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SqlSession</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写代码</p></li><li><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行sql，获取list合集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件</p><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.oddfar.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--select查询语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="测试">测试</h3><p>核心配置文件中注册 mappers</p><ul><li><p>junit测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步：获得SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一：getMapper</span></span><br><span class="line">    UserDao userDao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">    List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭SqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以能会遇到的问题：</p></li></ul><ol><li><p>配置文件没有注册</p></li><li><p>绑定接口错误。</p></li><li><p>方法名不对</p></li><li><p>返回类型不对</p></li><li><p>Maven导出资源问题</p></li><li><p>没有重写toString方法</p><blockquote><p>任何一个类都是从Object类继承下来的，因此在任何一个类里面都可以重写这个toString()方法。toString()方法的作用是<strong>当一个引用对象和字符串作连接的时候，或者是直接打印这个引用对象的时侯，这个引用对象都会自动调用toString()方法</strong>，通过这个方法返回一个表示引用对象自己正常信息的字符串，而这个字符串的内容由我们自己去定义，默认的字符串内容是“类名+哈希编码”。因此我们可以通过在类里面重写toString()方法，把默认的字符串内容改成我们自己想要表达的正常信息的字符串内容。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础语法</title>
      <link href="/2021/12/06/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/12/06/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java-基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识JAVA</title>
      <link href="/2021/11/30/%E5%88%9D%E8%AF%86JAVA/"/>
      <url>/2021/11/30/%E5%88%9D%E8%AF%86JAVA/</url>
      
        <content type="html"><![CDATA[<h2 id="Java的特性">Java的特性</h2><p><strong>1、跨平台/可移植性</strong></p><p>这是Java的核心优势。Java在设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。</p><p><strong>2、安全性</strong></p><p>Java适合于网络/分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使Java可以很容易构建防病毒，防篡改的系统。</p><p><strong>3、面向对象</strong></p><p>面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于C++为了照顾大量C语言使用者而兼容了C，使得自身仅仅成为了带类的C语言，多少影响了其面向对象的彻底性！</p><p>Java则是完全的面向对象语言。</p><p><strong>4、简单性</strong></p><p>Java就是C++语法的简化版，我们也可以将Java称之为“C+±”。跟我念“C加加减”，指的就是将C++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。</p><p>同时，由于语法基于C语言，因此学习起来完全不费力。</p><p><strong>5、高性能</strong></p><p>Java最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。</p><p>比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使Java程序的执行效率大大提高，</p><p>某些代码甚至接待C++的效率。因此，Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。</p><p><strong>6、分布式</strong></p><p>Java是为Internet的分布式环境设计的，因为它能够处理TCP/IP协议。事实上，通过URL访问一个网络资源和访问本地文件是一样简单的。Java还支持远程方法调用(RMI,Remote Method Invocation)，</p><p>使程序能够通过网络调用方法。</p><p><strong>7、多线程</strong></p><p>多线程的使用可以带来更好的交互响应和实时行为。 Java多线程的简单性是Java成为主流服务器端开发语言的主要原因之一。</p><p><strong>8、健壮性</strong></p><p>Java是一种健壮的语言，吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。</p><p>如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理</p><h2 id="JDK和JRE">JDK和JRE</h2><p><strong>JDK</strong></p><p>Java 2 SDK (Development Kit)包含：JRE的超集，包含编译器和调试器等用于程序开发的文件</p><p><strong>JRE</strong></p><p>Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序和Applet所必须文件</p><p>Java运行环境的三项主要功能：</p><ul><li>加载代码：由class loader 完成；</li><li>校验代码：由bytecode verifier 完成；</li><li>执行代码：由 runtime interpreter完成。</li></ul><p><strong>区别和联系</strong>：</p><p>sdk（也就是jdk）是jre的超集，是在jre的基础上增加了编译器及其他一些开发工具。</p><p>jre就是java运行时环境，包括了jvm和其它一些java核心api,任何一台电脑，只有安装了jre才可以行 java程序.</p><p>如果只是要运行JAVA程序，之需要JRE就可以。 JRE通常非常小，也包含了JVM.</p><p>如果要开发JAVA程序，就需要安装JDK。</p><h2 id="初识JVM">初识JVM</h2><p>JVM是一种规范，可以使用软件来实现，也可以使用硬件来实现，就是一个虚拟的用于执byte-codes 字节码的计算机。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。</p><p>JVM负责将java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。JAVA提供了另一种 解释运行的方法JIT（just in time），可以一次解释完，再运行特定平台上的机器码，高级的JIT可以只能 分析热点代码，并将这些代码转成本地机器码，并将结果缓存起来，下次直接从内存中调用，这样就大 大提高了执行JAVA代码的效率。这样就实现了跨平台、可移植的功能。</p><ol><li><p>JVM是指在一台计算机上由软件或硬件模拟的计算机；它类似一个小巧而高效的CPU。</p></li><li><p>byte-code代码是与平台无关的是虚拟机的机器指令。</p></li><li><p>java字节代码运行的两种方式:</p><ul><li><p>interpreter(解释)</p><p>运行期解释字节码并执行</p></li><li><p>Just-in-time(即时编译)</p><p>由代码生成器将字节代码转换成本机的机器代码,然后可以以较高速度执行。</p></li></ul></li></ol><p>JAVA的跨平台实现的核心是不同平台使用不同的虚拟机</p><p>不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。</p><h2 id="JAVA运行机制">JAVA运行机制</h2><h3 id="编译型语言">编译型语言</h3><p>编译型语言是先将源代码编译成机器语言（机器可以读懂的语言），再由机器运行机器码，这样执行程序的效率比较高。像C和C++就是典型的编译型语言。</p><h3 id="解释型语言">解释型语言</h3><p>其实解释型语言是相对编译型语言存在的，解释型语言是在运行的时候才进行编译，每次运行都需要编译，这样效率比较低。像JavaScript，Python就是典型的解释型语言</p><h3 id="二者的区别">二者的区别</h3><p>简单的举个例子：同样一本英文书，找人翻译成中文版的书然后拿给你看就是编译，找一个翻译员在你旁边给你解读书的含义就是解释。两者各有利弊，编译型语言执行效率高，翻译一次可以多次运行。解释性语言执行效率低，每次运行都需要重新翻译。但是解释型的跨平台性相对要好，比如解释给一个懂中文和解释给一个懂日文的人就叫做兼容性。</p><h3 id="JAVA运行机制-2">JAVA运行机制</h3><p>Java属于两者都有，既有编译过程，又是解释型语言</p><p>Java语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介 于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解 释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以 执行起来比“纯解释型”程序要快许多。</p><p>总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。</p><p>第一步：编译</p><p>利用编译器（javac）将源程序编译成字节码à 字节码文件名：源文件名.class</p><p>第二部：运行</p><p>利用虚拟机（解释器，java）解释执行class字节码文件。</p><p><img src="/img/pg/image-20210319180207773.png" alt="image-20210319180207773"></p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java-基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（五）处理器调度</title>
      <link href="/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/"/>
      <url>/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="处理机调度：调度的概念、时机、切换、过程以及调度方式和基本准则">处理机调度：调度的概念、时机、切换、过程以及调度方式和基本准则</h3><h4 id="调度的概念">调度的概念</h4><h5 id="调度的基本概念">调度的基本概念</h5><p>在多道程序系统中，进程的数量往往多于处理机的个数，进程争用处理机的情况就在所难免。处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、髙效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题。</p><h5 id="调度的层次">调度的层次</h5><p>一个作业从提交开始直到完成，往往要经历以下三级调度，如图2-4所示。</p><ol><li>作业调度。又称高级调度，.其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入/输出设备等必要的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。</li><li>中级调度。又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。</li><li>进程调度。又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</li></ol><h4 id="调度的时机、切换与过程">调度的时机、切换与过程</h4><p>进程调度和切换程序是操作系统内核程序。当请求调度的事件发生后，才可能会运行进程调度程序，当调度了新的就绪进程后，才会去进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，在操作系统内核程序运行时，如果某时发生了引起进程调度的因素，并不一定能够马上进行调度与切换。</p><p>现代操作系统中，不能进行进程的调度与切换的情况有以下几种情况。</p><ol><li>在处理中断的过程中：中断处理过程复杂，在实现上很难做到进程切换，而且<strong>中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</strong></li><li>进程在操作系统内核程序临界区中：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。</li><li>其他需要完全屏蔽中断的原子操作过程中：如加锁、解锁、中断现场保护、恢复等原子操作。<strong>在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</strong></li></ol><p><strong>如果在上述过程中发生了引起调度的条件，并不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。</strong></p><p>应该进行进程调度与切换的情况有：</p><ol><li><p>当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度。</p></li><li><p>当中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。</p></li></ol><p>进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入到当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p><h4 id="进程调度方式">进程调度方式</h4><p>所谓进程调度方式是指当某一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更髙的进程进入就绪队列，此时应如何分配处理机。</p><p>通常有以下两种进程调度方式：</p><ol><li><p>非剥夺调度方式，又称非抢占方式。是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。</p><p>在非剥夺调度方式下，一旦把CPU分配给一个进程，那么该进程就会保持CPU直到终止或转换到等待状态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。</p></li><li><p>剥夺调度方式，又称抢占方式。是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。.</p><p>釆用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有：优先权、短进程优先和时间片原则等。</p></li></ol><h4 id="调度的基本准则">调度的基本准则</h4><ol><li><p>CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU 保持“忙”状态，使这一资源利用率最髙。</p></li><li><p>系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。</p></li><li><p>周转时间。是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处迤机上运行以及进行输入/输出操作所花费时间的总和。</p></li></ol><blockquote><p>周转时间 = 作业完成时间 - 作业提交时间</p><p>平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n</p><p>带权周转时间是指作业周转时间与作业实际运行时间的比值</p><p>平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n</p><p>等待时间=开始时间—提交时间。</p></blockquote><hr><h3 id="操作系统典型调度算法">操作系统典型调度算法</h3><h4 id="先来先服务-FCFS-调度算法">先来先服务(FCFS)调度算法</h4><p>FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。</p><p>在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p><p>在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。</p><p><strong>FCFS调度算法属于不可剥夺算法</strong>。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。</p><p><strong>FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。</strong></p><h4 id="短作业优先-SJF-调度算法">短作业优先(SJF)调度算法</h4><p>短作业（进程）优先调度算法（Shortest Job First ）是指对短作业（进程）优先调度的算法。短<strong>作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</strong>。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p><p>SJF调度算法也存在不容忽视的缺点：</p><ul><li>该算法对长作业不利，SJF调度算法中长作业的周转时间会增加。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些 (即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”。后者是系统环形等待，前者是调度策略问题）。</li><li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。</li><li>由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</li></ul><p><strong>注意，SJF调度算法的平均等待时间、平均周转时间最少。</strong></p><h4 id="优先级调度算法">优先级调度算法</h4><p>优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。</p><p>在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p><p>根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：</p><ul><li>非剥夺式优先级调度算法。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。</li><li>剥夺式优先级调度算法。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。</li></ul><p>而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：</p><ul><li>静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。</li><li>动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。</li></ul><h4 id="高响应比优先调度算法">高响应比优先调度算法</h4><p><strong>高响应比优先调度算法主要用于作业调度</strong>，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p><p>响应比的变化规律可描述为：响应比R=等待时间+要求服务时间/要求服务时间</p><p>根据公式可知：</p><ul><li>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。<br>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</li><li>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</li></ul><h4 id="时间片轮转调度算法">时间片轮转调度算法</h4><p>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。</p><p>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（四）同步与异步的区别</title>
      <link href="/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>1、我们的生活中存在着很多同步异步的例子。</p><p>比如：你叫我去吃饭，我听到了就立刻和你去吃饭，如果我没有听到，你就会一直叫我，直到我听见和你一起去吃饭，这个过程叫同步；异步过程指你叫我去吃饭，然后你就去吃饭了，而不管我是否和你一起去吃饭。而我得到消息后可能立即就走，也可能过段时间再走。如果我请你吃饭，就是同步，如果你请我吃饭就用异步，这样你比较省钱。</p><p>2、在计算机领域</p><p>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；</p><p>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p><p>同步是阻塞模式，异步是非阻塞模式。</p><p>我的理解：同步是指两个线程的运行是相关的，其中一个线程要阻塞等待另外一个线程的运行。异步的意思是两个线程毫无相关，自己运行自己的。</p><p>举个例子：普通B/S模式（同步）AJAX技术（异步）</p><p>同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回  这个期间客户端浏览器不能干任何事</p><p>异步: 请求通过事件触发-&gt;服务器处理（这时浏览器仍然可以作其他事情）-&gt;处理完毕</p><p>当应用程序在对象上调用一个需要花费很长时间来执行的方法的时候，并且不需要让程序等待对方返回，这时就应该使用异步编程。</p><p>3、而我们平时经常讨论的同步问题多发生在多线程环境中的数据共享问题。即当多个线程需要访问同一个资源时，它们需要以某种顺序来确保该资源在某一特定时刻只能被一个线程所访问，如果使用异步，程序的运行结果将不可预料。因此，在这种情况下，就必须对数据进行同步，即限制只能有一个进程访问资源，其他线程必须等待。</p><p>实现同步的机制主要有临界区、互斥、信号量和事件</p><p>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资 源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</p><p>互斥量：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 .互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p><p>信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p><p>事件：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（三）进程同步</title>
      <link href="/2021/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2021/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="进程同步的基本概念：临界资源、同步和互斥">进程同步的基本概念：临界资源、同步和互斥</h3><h4 id="临界资源">临界资源</h4><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p><p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可以把临界资源的访问过程分成四个部分：</p><ul><li>进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li><li>临界区。进程中访问临界资源的那段代码，又称临界段。</li><li>退出区。将正在访问临界区的标志清除。</li><li>剩余区。代码中的其余部分。</li></ul><h4 id="同步">同步</h4><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><p>例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。</p><h4 id="互斥">互斥</h4><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p><p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时, 系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。</p><p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（二）进程和线程</title>
      <link href="/2021/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="进程的概念和特征">进程的概念和特征</h3><h4 id="进程的概念">进程的概念</h4><p>为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为 进程控制块 (Process Control Block, PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。所谓 创建进程，实质上是创建进程映像中的PCB ；而撤销进程，实质上是撤销进程的PCB。值得注意的是， 进程映像是静态的，进程则是动态的 。</p><p>注意：PCB是进程存在的唯一标志！</p><blockquote><p>从不同的角度，进程可以有不同的定义，比较典型的定义有：<br>进程是程序的一次执行过程。<br>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p></blockquote><p><strong>在引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：”进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。“</strong></p><h4 id="进程的特征">进程的特征</h4><p>进程是由多程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。<br>1）动态性：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。<br>2） 并发性：指多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征。<strong>引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。</strong><br>3）独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。<br>4） 异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、 不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制。<br>5） 结构性：每个进程都配置一个PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。</p><hr><h3 id="进程的状态和转换">进程的状态和转换</h3><p>进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化（一个进程会经历若干种不同状态）。通常进程有以下五种状态，运行状态、就绪状态、阻塞状态、创建状态、结束状态。前三种是进程的基本状态。</p><p><strong>注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。</strong></p><p>下图说明了五种进程状态的转换，而三种基本状态之间的转换如下：</p><p><img src="/img/pg/20150921073030742.png" alt="img"></p><p>就绪状态 -&gt; 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。</p><p>运行状态 -&gt; 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</p><p>运行状态 -&gt; 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</p><p>阻塞状态 -&gt; 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</p><hr><h3 id="进程控制：进程的创建、终止、阻塞、唤醒和切换">进程控制：进程的创建、终止、阻塞、唤醒和切换</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为原语，<strong>原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</strong></p><h4 id="进程的创建">进程的创建</h4><p>允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。</p><p>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。</p><h4 id="进程的终止">进程的终止</h4><p>引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。异常结束是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</p><h4 id="进程的阻塞和唤醒">进程的阻塞和唤醒</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</p><h4 id="进程切换">进程切换</h4><p>对于通常的进程，其创建、撤销以及要求由系统设备完成的I/O操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。</p><blockquote><p>注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。如果进程因中断或异常进入到核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的CPU现场，无需改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p></blockquote><hr><h3 id="进程的通信：共享存储、消息传递和管道通信">进程的通信：共享存储、消息传递和管道通信</h3><p>进程通信是指进程之间的信息交换。PV操作（通过、释放）是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。<br>1.共享存储<br>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。</p><p>需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。<br>2.消息传递<br>在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p><p>1）直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</p><p>2）间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。</p><p>3.管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p><hr><h3 id="线程的概念和多线程模型">线程的概念和多线程模型</h3><p><strong>引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；</strong><br><strong>而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</strong></p><p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p><p><strong>引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理机的分配单元。</strong></p><h4 id="线程与进程的比较">线程与进程的比较</h4><ol><li><p>调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p></li><li><p>拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源），但线程可以访问其隶属进程的系统资源。</p></li><li><p>并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。</p></li><li><p>系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、 I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预。</p></li><li><p>地址空间和其他资源（如打开的文件）：进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</p></li><li><p>通信方面：进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p></li></ol><h4 id="线程的属性">线程的属性</h4><p>在多线程操作系统中，把线程作为独立运行（或调度）的基本单位，此时的进程，已不再是一个基本的可执行实体。但进程仍具有与执行相关的状态，所谓进程处于“执行”状态，实际上是指该进程中某线程正在执行。线程的主要属性如下：</p><ol><li>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。</li><li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为它们创建成不同的线程。</li><li>同一进程中的各个线程共享该进程所拥有的资源。</li><li>线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务则可缩短进程的处理时间。</li><li>—个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（一）概述</title>
      <link href="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是操作系统">什么是操作系统</h3><p>操作系统是控制软硬件及方便用户使用的程序集合，目的是方便用户，提高资源利用率。操作系统是一种系统软件，是软、硬件资源的控制中心。</p><hr><h3 id="操作系统的基本特征">操作系统的基本特征</h3><p>操作系统的基本特征包括并发、共享、虚拟和异步。</p><h4 id="并发-Concurrence">并发(Concurrence)</h4><p>并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统 中，引入进程的目的是使程序能并发执行。</p><p>注意同一时间间隔（并发）和同一时刻（并行）的区别。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每一时刻，单处理机环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。橾作系统的并发性是通过分时得以实现的。</p><p>注意，并行性是指系统具有可以同时进行运算或操作的特性，在同一时刻完成两种或两种以上的工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。</p><h4 id="共享（Sharing">共享（Sharing)</h4><p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为以下两种资源共享方式：</p><ol><li>互斥共享方式<br>系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源。</li></ol><p>把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。<br>2) 同时访问方式<br>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即 “分时共享”。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p><p>并发和共享是操作系统两个最基本的特征，这两者之间又是互为存在条件的：<br>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；<br>若系统不能对资源共享实施有效的管理，也必将影响到程序的并发执行，甚至根本无法并发执行。</p><h4 id="虛拟（Virtual">虛拟（Virtual)</h4><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备等。</p><p>在虚拟处理器技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU)在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的CPU,称为虚拟处理器。</p><p>因此，操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器</p><h4 id="异步-Asynchronism">异步(Asynchronism)</h4><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误 (就像对全局变量的访问顺序不当会导致程序出错一样）。但是只要运行环境相同，操作系统必须保证多次运行进程，都获得相同的结果。</p><hr><h3 id="操作系统目标和功能">操作系统目标和功能</h3><p>为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：处理机管理、 存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p><hr><h3 id="操作系统的运行机制">操作系统的运行机制</h3><p>计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序；另一种是用户自编程序或系统外层的应用程序。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”要执行一些特权指令，而“被管理程序”出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如I/O指令、 置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等指令。操作系统在具体实现上划分了用户态（目态）和核心态（管态)，以严格区分两类程序。</p><p>内核是计算机上配置的底层软件，是计算机功能的延伸。不同系统对内核的定义稍有区别，大多数操作系统内核包括四个方面的内容。</p><h4 id="时钟管理">时钟管理</h4><p>在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。诸如，在分时操作系统中，釆用时间片轮转调度的实现；在实时系统中，按截止时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于时钟。</p><h4 id="中断机制">中断机制</h4><p>引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。</p><p>中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</p><h4 id="原语">原语</h4><p>按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。其特点是：<br>它们处于操作系统的最底层，是最接近硬件的部分。<br>这些程序的运行具有原子性——其操作只能一气呵成（这主要是从系统的安全性和便于管理考虑的）。<br>这些程序的运行时间都较短，而且调用频繁。</p><p>通常把具有这些特点的程序称为原语（Atomic Operation)。定义原语的直接方法是关闭中断，让它的所有动作不可分割地进行完再打开中断。</p><p>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可以定义为原语，使它们成为内核的组成部分。</p><h4 id="系统控制的数据结构及处理">系统控制的数据结构及处理</h4><p>系统中用来登记状态信息的数据结构很多，比如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下三种：<br>进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等。<br>存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。<br>设备管理：缓冲区管理、设备分配和回收等。</p><p>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。</p><hr><h3 id="中断和异常的概念">中断和异常的概念</h3><p>​           在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换。操作系统内核工作在核心态，而用户程序工作在用户态。但系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。因此，需要在核心态建立一些“门”，实现从用户态进入核心态。在实际操作系统中，CPU运行上层程序时唯一能进入这些“门”的途径就是通过中断或异常。当中断或异常发生时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的（例如，用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，只需将该位置0即可)。中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。</p><ol><li><p>中断(Interruption)，也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入 / 输出请求，同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们与当前处理机运行的程序无关。</p></li><li><p>异常(Exception)，也称内中断、例外或陷入(Trap)，指源自CPU执行指令内部的事件，如程序的非法操作码、 地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。</p></li></ol><hr><h3 id="系统调用">系统调用</h3><p>所谓系统调用就是用户在程序中调用操作系统所提供的一些子功能，系统调用可以被看做特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I/0传输以及管理文件等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十乃至上百条之多。</p><p>这些系统调用按功能大致可分为如下几类：<br>设备管理。完成设备的请求或释放，以及设备启动等功能。<br>文件管理。完成文件的读、写、创建及删除等功能。<br>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。<br>进程通信。完成进程之间的消息传递或信号传递等功能。<br>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</p><p>显然，系统调用运行在系统的核心态。通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令。系统调用命令是由操作系统提供的一个或多个子程序模块实现的。</p><p>这样，操作系统的运行环境可以理解为：用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。当管理程序运行结束时，用户程序需要继续运行，则通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行。</p><blockquote><p>下面列举一些由用户态转向核心态的例子：<br>用户程序要求操作系统的服务，即系统调用。<br>发生一次中断。<br>用户程序中产生了一个错误状态。<br>用户程序中企图执行一条特权指令。<br>从核心态转向用户态由一条指令实现，这条指令也是特权命令。一般是中断返回指令。</p><p>注意：由用户态进入核心态，不仅仅是状态需要切换。而且，所使用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍历Map的四种方式</title>
      <link href="/2021/10/06/%E9%81%8D%E5%8E%86Map%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/10/06/%E9%81%8D%E5%8E%86Map%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="Entry">Entry</h3><p>由于Map中存放的元素均为键值对，故每一个键值对必然存在一个映射关系。<br>Map中采用Entry内部类来表示一个映射项，映射项包含Key和Value (我们总说键值对键值对, 每一个键值对也就是一个Entry)<br>Map.Entry里面包含getKey()和getValue()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it&#x3D;map.entrySet().iterator();</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;Integer,Integer&gt; entry&#x3D;it.next();</span><br><span class="line">        int key&#x3D;entry.getKey();</span><br><span class="line">        int value&#x3D;entry.getValue();</span><br><span class="line">        System.out.println(key+&quot; &quot;+value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="entrySet">entrySet</h3><p>entrySet是 java中 键-值 对的集合，Set里面的类型是Map.Entry，一般可以通过map.entrySet()得到。</p><p>entrySet实现了Set接口，里面存放的是键值对。一个K对应一个V。<br>用来遍历map的一种方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entryseSet&#x3D;map.entrySet();</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry:entryseSet) &#123;</span><br><span class="line">System.out.println(entry.getKey()+&quot;,&quot;+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即通过getKey（）得到K，getValue得到V。</p><h3 id="keySet">keySet</h3><p>还有一种是keySet, keySet是键的集合，Set里面的类型即key的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set &#x3D; map.keySet();</span><br><span class="line">for (String s:set) &#123;</span><br><span class="line">System.out.println(s+&quot;,&quot;+map.get(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四种遍历Map方式">四种遍历Map方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(&quot;1&quot;, &quot;value1&quot;);</span><br><span class="line">map.put(&quot;2&quot;, &quot;value2&quot;);</span><br><span class="line">map.put(&quot;3&quot;, &quot;value3&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第一种：普遍使用，二次取值</span><br><span class="line">System.out.println(&quot;通过Map.keySet遍历key和value：&quot;);</span><br><span class="line">for (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(&quot;key&#x3D; &quot;+ key + &quot; and value&#x3D; &quot; + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二种</span><br><span class="line">System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;);</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it &#x3D; map.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; entry &#x3D; it.next();</span><br><span class="line">    System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第三种：推荐，尤其是容量大时</span><br><span class="line">System.out.println(&quot;通过Map.entrySet遍历key和value&quot;);</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第四种</span><br><span class="line">System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;);</span><br><span class="line">for (String v : map.values()) &#123;</span><br><span class="line">    System.out.println(&quot;value&#x3D; &quot; + v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的容器类及区别</title>
      <link href="/2021/10/05/java%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/05/java%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="分类：大类型主要分为以下两种类型">分类：大类型主要分为以下两种类型</h3><p>１）Collection：一个独立元素的序列，这些元素都服从一条或者多条规则。 List必须按照插入的顺序保存元素，而set不能有重复的元素。Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。</p><p>2）Map：一组成对的“键值对”对象，允许你使用键来查找值。</p><img src="/img/pg/col.png" alt="col" style="zoom:75%;" /><h3 id="具体区别">具体区别</h3><p>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主要方法:</span><br><span class="line">boolean add(0bject o) 添加对象到集合</span><br><span class="line">boolean remove (0bject o)删除指定的对象</span><br><span class="line">int size()返回当前集合中元素的数量</span><br><span class="line">boolean contains (0bject 0)查找集合中是否有指定的对象</span><br><span class="line">boolean isEmpty()判断集合是否为空</span><br><span class="line">Iterator iterator()返回- 一个迭代器</span><br><span class="line">boolean containsAll(Collection c)查找集合中是否有集合c中的元素</span><br><span class="line">boolean addAll(Collection c)将集合c中所有的元素添加给该集合</span><br><span class="line">void clear()删除集合中所有元素</span><br><span class="line">void removeAll(Collection c)从集合中删除c集合中也有的元素</span><br><span class="line">void retainAll(Collection c)从集合中删除集合c中不包含的元素</span><br></pre></td></tr></table></figure><h4 id="List接口">List接口</h4><p>实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p><p>共同点：</p><p>​      LinkedList、ArrayList都实现了List接口，都是不同步的，线程不安全，元素是有序的、可重复。</p><p>1）LinkedList类</p><p>​     基于链表的数据结构，允许null元素，增加、删除、修改元素方面效率比ArrayList高。   此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p><p><strong>注意:LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…));</strong></p><p>2)ArrayList类</p><p>基于数组的数据结构，不同步，线程不安全，查询（get set）效率高。</p><p>size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p><p><strong>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</strong></p><h4 id="Array和ArrayList的区别及各自适用的场景">Array和ArrayList的区别及各自适用的场景</h4><p>Array是数组，ArrayList是Array的加强版。</p><p>（1）array可以保存基本类型和对象类型，arrayList只能保存对象类型</p><p>（2）array数组的大小是固定的不能更改，而ArrayList的大小可以改变</p><p>（3）Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。</p><p>（4）ArrayList有更加丰富的方法如addAll（）、removeAll()、iterator()</p><p>适用场景：</p><p>如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不经常对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，可以考虑选LinkedList。</p><p>3）Vector类</p><p>Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个 Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。</p><p>4）Stack 类</p><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有 peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p><h4 id="Set接口">Set接口</h4><p>共同点:元素不重复</p><p><strong>1）HashSet类</strong></p><p>-&gt;不保证集合中元素的顺序</p><p>-&gt;允许包含值为null的元素，但最多只能有一个null元素。</p><p><strong>2）TreeSet</strong></p><p>TreeSet描述的是Set的一种变体——可以实现排序等功能的集合，它在将对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中，并保证该集合元素组成的对象序列时刻按照“升序”排列。所以我们在使用TreeSet时候，里面装的元素一定是有序的，否则就不应该选择TreeSet。</p><p><strong>3)LinkedSet</strong></p><p>集合元素按插入顺序排列。</p><p>适用场景：</p><p>HashSet使用哈希表实现的，元素是无序的。添加、删除操作时间复杂度都是O(1)。TreeSet内部结构是一个树结构(红黑树)，元素是有序的，添加、删除操作时间复杂度为O(log(n))，并且提供了first(), last(), headSet(), tailSet()等方法来处理有序集合。</p><p>LinkedHashSet是介于HashSet 和 TreeSet之间，内部是一个双向链表结构，所以它的插入是有序的，时间复杂度是O(1)。</p><p>简而言之,如何你需要的是一个快速的集合，建议你使用HashSet，如果你需要的是一个排序集合，请选择TreeSet，如果你需要一套能够存储插入顺序的集合,请使用LinkedHashSet。</p><h4 id="Map集合接口">Map集合接口</h4><p>Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p><p><strong>HashTable和HashMap区别</strong></p><p>第一、继承不同。</p><p>public class Hashtable extends Dictionary implements Map</p><p>public class HashMap extends AbstractMap implements Map</p><p>第二、Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p><p>第三、Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。<strong>当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</strong></p><p>第四、两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。</p><p>第五、哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p><p>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值。</p><p>Hashtable计算hash值，直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</p><p>第六，内部实现使用的数组初始化和扩容方式不同。</p><p>HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</p><p>Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</p><p>适用场景：</p><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p><p>1、由于HashMap非线程安全，在只有一个线程访问的情况下，效率要高于HashTable</p><p>2、HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p><p>3、HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。因为contains方法容易让人引起误解。</p><p>4、Hashtable继承自陈旧的Dictionary类，而HashMap是Java1.2引进的Map 的一个实现。</p><p>5、两者通过hash值散列到hash表的算法不一样，HashTbale是古老的除留余数法，直接使用hashcode，而后者是强制容量为2的幂，重新根据hashcode计算hash值，在使用hash 位与 （hash表长度 – 1），也等价取膜，但更加高效，取得的位置更加分散，偶数，奇数保证了都会分散到。前者就不能保证。</p><p>6、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p><p>fail-fast和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set方法，将会抛出IllegalArgumentException异常。</p><p>结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p><p>该条说白了就是在使用迭代器的过程中有其他线程在结构上修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p><h4 id="LinkedHashMap和HashMap的区别">LinkedHashMap和HashMap的区别</h4><ul><li>HashMap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。</li><li>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。也可以在构造时带参数，按照应用次数排序。</li><li>LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序插入顺序 、 访问顺序<br>1.插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序<br>2.访问顺序：所谓访问指的是get/put操作，对一个键执行get/put操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的小芝士</title>
      <link href="/2021/09/25/java%E4%B8%AD%E7%9A%84%E5%B0%8F%E8%8A%9D%E5%A3%AB/"/>
      <url>/2021/09/25/java%E4%B8%AD%E7%9A%84%E5%B0%8F%E8%8A%9D%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="JAVA-构造方法和get，set方法的区别与联系">JAVA 构造方法和get，set方法的区别与联系</h3><p>联系：<br>都可以给对象赋值，都可以访问private私有属性<br>区别：<br>构造方法是一次性用品，是初始化对象的时候调用的，而get/set方法则可以多次修改对象的属性<br>构造方法赋值的时候可以不加引用，如：new 类名( , , , ,)，直接可以开辟空间，而get/set方法必须要有引用<br>最终要的一点是在属性私有化的时候，setget方法可以实现从外部类对属性的访问</p><h3 id="怎么判断两个对象是否为同一个对象">怎么判断两个对象是否为同一个对象</h3><h4 id="equals（）">equals（）</h4><p>equals（）是Object中的方法，比较的对象的内存地址</p><h4 id="hashCode（）">hashCode（）</h4><p>比较的哈希码中的索引位置。可以快速定位对象的物理位置，能提高查找效率。</p><p>equals（）相等，hashCode（）一定相等<br>hashCode（）不相等，equals（）一定不相同<br>hashCode（）相等，equals不一定相等</p><h4 id="equals（）和hashCode（）">equals（）和hashCode（）</h4><ul><li><p>​         java中相同对象有两个：1、引用地址符都相同的对象属于同一个对象  2、所指对象的内容完全一致属于同一个对象</p></li><li><p>​         比较两个自定义对象是否属于同一个对象时，我们要重写自定义对象中的equals()方法，否则，当使用equals（）比较时，会自动去调用Object类中的equals（）方法，而Object类中的equals（）方法实则是比较两个对象的引用地址符是否相当，而不会去比较内容是否相等，这样两个不同的的自定义的对象比较时，永远返回的是false.</p></li></ul><blockquote><p>​        在hashSet中使用，hashset是元素无序，不重复的集合。先有一个例子看一下其实hashSet也是可以添加重复元素的。</p><p>​        看这个结果hashSet无序倒是体现出来了，但是里面为什么被添加了重复元素？难道是hashSet元素不可以重复是错误？当然不是啦！首先我们分析一下hashSet中我们是怎么添加元素的，由上图可见我们每次添加的对象都是new出来的，使用new就是创建一个对象，既然每次都创建了一个新的对象，hashCode（）可能就不相同，hashSet自然就把他们当做不同对象添加到集合里面啦。那么对于自定义对象我们才能保持不重复呢？如下：重写自定义对象的equals（）和hashCode（）来比较对象内容后</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override &#x2F;&#x2F;重写hashcode</span><br><span class="line">public int hashCode () &#123;</span><br><span class="line">return this .getId () +this . getName () . hashCode () ;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;重写equals()</span><br><span class="line">@Override</span><br><span class="line">public boolean equals (object obj) &#123;</span><br><span class="line">if (this&#x3D;&#x3D;obj)   &#123;return true ;&#125;</span><br><span class="line">        if (obj instanceof Items) &#123;</span><br><span class="line">Items i &#x3D; (Items) obj ;</span><br><span class="line">if (this.getId()&#x3D;&#x3D; i.getId () &amp;&amp;this.getName().equals(i.getName()))                   &#123;return true ; &#125;</span><br><span class="line">else    &#123; return false ;&#125;</span><br><span class="line">&#125;</span><br><span class="line">else  &#123;return false ;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java堆内存和栈内存的区别">Java堆内存和栈内存的区别</h3><blockquote><ol><li>栈：为编译器自动分配和释放，如函数参数、局部变量、临时变量等等</li><li>堆：为成员分配和释放，由程序员自己申请、自己释放。否则发生内存泄露。典型为使用new申请的堆内容</li><li>静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li></ol></blockquote><p>1.不论对象什么时候创建，他都会存储在堆内存中，栈内存包含它的引用。栈内存只包含原始值变量好和堆中对象变量的引用。</p><p>2.存储在堆中的对象是全局可以被访问的，然而栈内存不能被其他线程所访问。</p><h3 id="引用和对象的关系">引用和对象的关系</h3><p>​      因为在java中对象是没有名字的，所以我们是用引用变量来控制某某类型的对象的， 即通过引用变量来调用这个对象中的成员(成员变量,成员方法).</p><p>Vehicle veh1 = new Vehicle(); 通常把这条语句的动作称之为创建一个对象，其实，它包含了四个动作。</p><p>​      1.new Vehicle，是以Vehicle类为模板，在堆空间里创建一个Vehicle类型的对象（简称为Vehicle对象）。<br>​      2.末尾的()意味着，在对象创建后，立即调用Vehicle类的构造函数,根据括号中有无参数进而来调用相应Vehicle类中的构造方法,对刚生成的对象进行初始化。</p><p>​      3.Vehicle veh 表示在栈中创建了一个Vehicle类型的引用变量。即Vehicle类型的引用。他的作用是可以指向Vehicle类型的对象.即他可以存储Vehicle类型对象在堆中的地址。</p><p>​      4.“=”操作符的作用是使引用变量指向刚刚创建的那个Vehicle对象。或者说将对象在堆中的地址赋值给引用变量<br>即使对象和引用变量之间关联起来。</p><h3 id="LinkedHashMap和HashMap的区别">LinkedHashMap和HashMap的区别</h3><p>区别：</p><ul><li>LinkedHashMap是继承于HashMap，是基于HashMap和双向链表来实现的。</li><li>HashMap无序；LinkedHashMap有序，可分为插入顺序和访问顺序两种。如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。</li><li>LinkedHashMap存取数据，还是跟HashMap一样使用的Entry[]的方式，双向链表只是为了保证顺序。</li><li>LinkedHashMap是线程不安全的。</li></ul><p>应用场景：</p><p>​    HashMap是无序的，当我们希望有顺序地去存储key-value时，就需要使用LinkedHashMap了。</p><h3 id="Java中的强制类型转换">Java中的强制类型转换</h3><p><strong>1 ) 整数 int 转换成字串 String , 有三种方法 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; String.valueOf(i);</span><br><span class="line">String s &#x3D; Integer.toString(i);</span><br><span class="line">String s &#x3D; &quot;&quot; + i;</span><br></pre></td></tr></table></figure><p><strong>2 ) String 转 int</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; Integer.parseInt([String]);</span><br><span class="line">i &#x3D; Integer.parseInt([String],[int radix]);</span><br><span class="line">int i &#x3D; Integer.valueOf(my_str).intValue();</span><br></pre></td></tr></table></figure><p><strong>3 ) 布尔类型 转 String</strong></p><ol><li>第一种方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean bool &#x3D; true;</span><br><span class="line">String s &#x3D; new Boolean(bool).toString();&#x2F;&#x2F;将bool利用对象封装器转化为对象</span><br></pre></td></tr></table></figure><ol start="2"><li>第二种方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean bool &#x3D; true; </span><br><span class="line"></span><br><span class="line">String s &#x3D; String.valueOf( bool );</span><br></pre></td></tr></table></figure><p><strong>4 ) String 转 Date</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导入 java.util.Date date&#x3D;null;</span><br><span class="line"></span><br><span class="line">date&#x3D;java.sql.Date.valueOf(String s);</span><br></pre></td></tr></table></figure><p><strong>5 ) 数字类型间的转换</strong></p><p>转型有两种: 向上转型和向下转型(强制转型)<br>两种分别如下:<br>第一种是向上转型<br>对于基础数据类型 , 可以自动转型 ,比如:<br>int a = 10;<br>long b = a;<br>这里就是把int型转成了long型 , 因为 long范围比int大 , 这样的转型不会有任何影响 , 所以可以自动转型</p><p>第二种是向下转型 , 也就是强制<br>这种需要强转 , 比如<br>long a = 10 ;<br>int b = (int) a;<br>通过 (int)可以强制转型 , 但是这样会丢失精度 , 比如a如果超过了b的范围 , 那么强转成int型, 只会等于int的最大值</p><p>又如 : int a = ( int ) 8.8 ;</p><h3 id="Serializable的使用">Serializable的使用</h3><p>Serializable：可序列化接口。     序列化：将对象转换为字节流。   反序列化：将字节流转换为对象。</p><p>定义实体类会实现Serializable接口，目的就是为了把对象持久化存储或者网络比特流传输。</p><p>Serializable相当于转换层，把对象转换成字节流，传字节流比传比对象实例 更方便机器的存取。传输之前就之后转成字节流，以免传输时进行判断或者占用其他空间、时间 进行 字节流转换。</p><p>serialVersionUID有两种显示的生成方式：<br>一是默认的1L，比如：private static final long serialVersionUID = 1L;<br>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段</p><p>作用是用来验证 对象的发送方和接收方是否已经加载。什么意思：在<strong>反序列化时，<strong>JVM会将传输过来的</strong>serialVersionUID</strong>与本地实体类的对比，如果相同，反序列化成功，若不同则反序列化失败。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java容器的遍历</title>
      <link href="/2021/09/23/java%E5%AE%B9%E5%99%A8%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2021/09/23/java%E5%AE%B9%E5%99%A8%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代器">迭代器</h3><h4 id="迭代器的介绍">迭代器的介绍</h4><p>迭代器是用于遍历集合中的元素的一种方式。Java集合框架中的迭代器是Iterator接口，该接口位于java.util包下</p><h4 id="迭代器的创建和使用">迭代器的创建和使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Object&gt; it&#x3D; c.iterator();&#x2F;&#x2F;获取迭代器对象</span><br></pre></td></tr></table></figure><h5 id="hasNext-方法">hasNext()方法</h5><p>hasNext()方法的作用：判断集合中是否还有元素，如果还有元素可以迭代，则返回true，否则返回false。</p><h5 id="next-方法">next()方法</h5><p>next()方法作用：返回集合中下一个集合元素。该方法一般和hasNext()方法结合使用，当hasNext()方法判断还有下一个元素时，则可以使用next()方法获取到集合元素。</p><h3 id="使用迭代器遍历">使用迭代器遍历</h3><h4 id="迭代器-KeySet">迭代器 KeySet</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Private  HashMap &lt;Items,Integer&gt; goods&#x3D; new HashMap&lt;Items,integer&gt; (); &#x2F;&#x2F;获取商品集合，（integer是一种int的包装类，须实例化使用；Items是商品类）</span><br><span class="line"></span><br><span class="line"> Set&lt;Items&gt; keys&#x3D;goods.keyset();获取键的集合；</span><br><span class="line"> Iterator&lt;Items&gt; it&#x3D;keys.iterator();获取迭代器对象；</span><br><span class="line"> while(it.hasNext())&#123;</span><br><span class="line">   Items i&#x3D;it.Next(); 获取商品对象</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器-EntrySet">迭代器 EntrySet</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private  Hashmap&lt;Items,Integer&gt; goods&#x3D;new Hashmap&lt;Items,Integer&gt;();&#x2F;&#x2F;创建商品集合对象</span><br><span class="line">  Set&lt;Items,Integer&gt; entrys&#x3D;goods.entryset(); 获取键值对集合</span><br><span class="line">  Interator it&#x3D;entrys.Interator();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用Foreach遍历">使用Foreach遍历</h3><p>foreach语句语法类型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型x 元素变量y :遍历对象z)&#123;</span><br><span class="line">    遍历元素变量y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">list.add(&quot;c&quot;);</span><br><span class="line">for(String y :list)&#123;</span><br><span class="line">    System.out.println(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种遍历方式的区别">三种遍历方式的区别</h3><h4 id="条件差别">条件差别</h4><p>for需要知道数组或者集合的大小，而且需要有序的，不然无法遍历；</p><p>foreach和iterator不需要知道数组或者集合的大小，他们都是得到集合内的每一个元素然后进行处理；</p><h4 id="多态差别">多态差别</h4><p>for和foreach都需要知道自己的集合类型，甚至要知道自己集合内的元素类型，不能实现多态。这个使用的语法上都可以表示出来。</p><p>Iterator是一个接口类型，它不关心集合的类型和集合内的元素类型，因为它是通过hasnext和next来进行下一个元素的判断和获取，这一切都是在集合类型定义的时候就完成的事情。迭代器统一了对容器的访问模式，这也是对接口解耦的最好表现。</p><h4 id="用法差别">用法差别</h4><p>for一般可以用于简单的顺序集合，并且可以预测集合的大小；</p><p>foreach可以遍历任何集合或者数组，但是使用者需要知道遍历元素的类型。</p><p>iterator是最强大的，它可以随之修改元素内部的元素。可以在遍历的时刻用remove（）！！！！我的意思是其他两个都不可以！！！</p><p>而且iterator不需要知道元素类型和元素大小，通过hasnext（）判断是否遍历完所有元素。</p><p>而且在对范型的集合进行遍历的时候，iterator是不二的选择，就是因为不需要知道元素类型便可以遍历。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet学习</title>
      <link href="/2021/09/16/Servlet%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/09/16/Servlet%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是servlet">什么是servlet</h3><p>​    在 JavaWeb 项目中，处理请求和发送响应的过程是由一种叫做 Servlet 的程序来完成的，并且 Servlet 是为了解决实现动态页面而衍生的东西。</p><p>简单来讲：Servlet其实就是一个遵循Servlet开发的java类，Serlvet是由服务器调用的，运行在服务器端。</p><h3 id="Tomcat-和-Servlet-的关系">Tomcat 和 Servlet 的关系</h3><p>​     Tomcat 是Web应用服务器，是一个Servlet/JSP容器。 Tomcat 作为 Servlet 容器，负责处理客户请求,把请求传送给 Servlet，并将 Servlet 的响应传送回给客户，而 Servlet 是一种运行在支持 Java 语言的服务器上的组件。</p><p>①：Tomcat 将 Http 请求文本接收并解析，然后封装成 HttpServletRequest 类型的 request 对象，所有的 Http 头数据读可以通过request 对象调用对应的方法查询到。</p><p>②：Tomcat 同时会要响应的信息封装为 HttpServletResponse 类型的response 对象，通过设置 response 属性就可以控制要输出到浏览器的内容，然后将 response 交给 Tomcat，Tomcat 就会将其变成响应文本的格式发送给浏览器。</p><p>Java Servlet API 是Servlet容器(tomcat)和servlet之间的接口，它定义了Serlvet 的各种方法，还定义了 Servlet 容器传送给 Servlet 的对象类，其中最重要的就是 ServletRequest 和 ServletResponse 。所以说我们在编写Servlet时，需要实现 Servlet 接口，按照其规范进行操作。</p><h3 id="编写servlet">编写servlet</h3><p><strong>我们要继承 HttpServlet类 那么问题来了，继承HttpServlet 和实现Servlet 有什么区别？</strong></p><p>首先，直观的不同，Servlet 是一个接口，如果实现这个接口，那么就必须实现接口里面定义的所有方法。</p><p>而 HttpServlet 实现了 Servlet 接口，并把 Servlet 接口中的方法实现了。<br>继承 Httpservelt，实际上也就实现了 Servlet 接口。</p><p>但是我们没必要再去实现 Servlet 中定义的生命周期方法，因为在 Httpservlet 中已经有了默认实现，并且这些默认实现也挺规范和实用， doget 和 dopost 是执行用户请求的终点，get 请求会调用 doget 方法，post 请求会执行 dopost 方法，我们可以在这2个方法中定义我们自己的业务逻辑。</p><p>最后，HttpServlet 在实现 Servlet 接口的时候，已经实现了 Servlet 中所有的方法，因此继承自 HttpSrvlet 的类，不需要再去覆写相应的生命周期等方法。</p><h4 id="编写Java类，继承HttpServlet">编写Java类，继承HttpServlet</h4><p>创建一个 MyServlet java 类，继承 HttpServlet 实现 service 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置字符编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">        <span class="comment">//从 request 对象中获取username,password</span></span><br><span class="line">        String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;password&quot;</span>,password);</span><br><span class="line">        request.getRequestDispatcher( <span class="string">&quot;/index2.jsp&quot;</span>).forward(request, response);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置web-xml文件">配置web.xml文件</h4><p>web.xml 配置 Servlet 访问路径，能让别人通过链接访问到你的 Servlet：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;MyServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;club.sscai.demo.MyServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;MyServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;MyServlet&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure><h4 id="jsp-界面显示">jsp 界面显示</h4><p>index2.jsp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;2222222&lt;&#x2F;h2&gt;</span><br><span class="line">username: &lt;%&#x3D;request.getParameter(&quot;username&quot;) %&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">password: &lt;%&#x3D;request.getParameter(&quot;password&quot;) %&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>前台界面附带的参数，可以通过 request 获取，这也证实了前面 <strong>HttpServletRequest 封装了 request对象，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中。</strong></p><p>关于 request\response，在实际项目开发中，request 是非常常用的，毕竟你要拿到用户请求的信息，才能知道用户要什么，但是，像上文中这种继承自 HttpServlet 是不会出现的，例如，采用 Spring MVC 框架后，自动帮我们实现了 <strong>request 请求到 Controller</strong> 的骚操作。</p><p>servlet中out.write()和out.print()的区别</p><p>重载的print方法可将各种类型的数据转换成字符串的形式输出，而重载的write方法只能输出字符、字符数组和字符串等与字符相关的数据</p><p>字符串比较之中“==”和equals()的区别？</p><p>==：比较的是两个字符串内存地址的数值是否相等，属于数值比较；</p><p>equals()：比较的是两个字符串的内容，属于内容比较。</p><p>以后进行字符串相等判断的时候都使用equals()</p><h3 id="ServletContext与ServletConfig的详解及区别">ServletContext与ServletConfig的详解及区别</h3><h4 id="servletContext详解">servletContext详解</h4><p>​      ServletContext是servlet与servlet容器之间的直接通信的接口。Servlet容器在启动一个Web应用时，会为它创建一个servletContext对象。每个web应用有唯一的servletContext对象。同一个web应用的所有servlet对象共享一个serveltContext,servlet对象可以通过它来访问容器中的各种资源。该接口获取的是web应用的初始化信息。</p><h4 id="servletConfig详解">servletConfig详解</h4><p>​      Servlet容器初始化一个servlet对象时，会为这个servlet对象创建一个servletConfig对象。在servletConfig对象中包含了servlet的初始化参数信息。此外，servletConfig对象还与servletContext对象关联。Servlet容器在调用servlet对象的init(ServletConfig config)方法时，会把servletConfig对象当做参数传递给servlet对象。Init(ServletConfig config)方法会使得当前servlet对象与servletConfig对象建立关联关系。</p><h4 id="二者区别">二者区别</h4><p>首先从作用范围来说，ServletConfig作用于某个特定的Servlet，即从该Servlet实例化，那么就开始有效，但是该Servlet之外的其他Servlet不能访问；ServletContext作用于某个web应用，即在一个web应用中相当于一个全局对象，在Servlet容器启动时就已经加载，对于不同的web应用，有不同的ServletContext。</p><p>其次，来看一下二者参数的使用。如果一个参数为整个web应用所用，那么就配置为ServletContext参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">  &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">  &lt;param-value&gt;gb2312&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure><p>如果一个参数仅为一个Servlet所用，那么就应该配置为ServletConfig参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;affice_add&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;servlet.Affice_add&lt;&#x2F;servlet-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">   &lt;param-name&gt;filepath&lt;&#x2F;param-name&gt;</span><br><span class="line">   &lt;param-value&gt;&#x2F;webContent&#x2F;affice&lt;&#x2F;param-value&gt;</span><br><span class="line">  &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br></pre></td></tr></table></figure><h3 id="5-Servlet中文编码问题">5.Servlet中文编码问题</h3><p>实际遇到更多的乱码情况是浏览器接收响应数据的乱码， 所以我们要做的使响应所回送数据所用字符集 和 浏览器用来解析回送数据所用字符集相同。</p><p>设置浏览器的解码格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>大白话说就是用 content-type 响应头，告诉浏览器我回送过来的数据时 text/html 类型，要用 UTF-8 字符集解码；</p><p>设置好浏览器用于解析响应回送数据的字符集后，现在要设置响应回送的数据字符集，分为两种情况，也就是最开始提到的，处理字节和字符流数据是有差异的：</p><ol><li>使用 response.getWriter() 流写出的的数据乱码解决方式：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置将发送到客户端的响应 的字符编码，只能用于设置 getWritet()的字符编码</span></span><br><span class="line">response.setCharactEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//同时设置浏览器的解码方式</span></span><br><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>需要在调用 getWriter() 方法前 和 响应提交前使用</p></blockquote><ol><li>使用 response.getOutputStream() 流写出的数据乱码解决方式：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端对字符进行编码的时候，指定编码方式</span></span><br><span class="line">response.getOutputStream().write(<span class="string">&quot;汉字&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"><span class="comment">//同时设置浏览器的解码方式</span></span><br><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>字符响应流只用用来输出字符，而字节响应流可以用来输出任何东西</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jsp技术</title>
      <link href="/2021/07/30/Jsp%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/07/30/Jsp%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Java-Server-Pages">什么是Java Server Pages?</h3><p>​    JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p><p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p><p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p><p>JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。</p><h3 id="表单的两种提交方式get和post">表单的两种提交方式get和post</h3><p>定义在<code>&lt;form action=&quot;dologin.jsp&quot; name=&quot;loginForm&quot; method=&quot;提交方式***&quot;&gt;&lt;/form&gt;</code>   动作／名称等顺序无所谓。<br>1.get：以【明文】方式，通过URL提交数据，数据在URL中【可以看到】。提交数据最多不超过【2KB】。安全性较低，但效率比post方式高。适合提交数据量不大，且安全要求不高的数据：比如：搜索、查询等功能。<br>2.post：将用户提交的信息封装在HTML HEADER内。适合提交数据量大，安全性高的用户信息。如：注册、修改、上传等功能。</p><h3 id="request请求">request请求</h3><p><strong>request对象：<strong>客户端的</strong>一次请求</strong>（JSP页面通过request对象请求服务器跳转某一页面，只在该页面中有效，其他页面这个request对象无作用）信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是<strong>HttpServletRequest类</strong>的实例。request对象具有<strong>请求域</strong>，即完成客户端的请求之前，该对象一直有效。</p><p>客户端向服务端传参的方式：</p><p>1.通过表单 post、get方式。</p><blockquote><p>request.setCharacterEncoding(utf-8)解决中文乱码</p></blockquote><p>2.通过URL地址传</p><blockquote><p>service.xml中   设置<code>&lt;connector  URLEncoding=&quot;utf-8&quot;  &gt;</code> 解决中文乱码为防止出现提交表单后产生中文乱码问题，应该在request接收参数之前添加指令<br>&lt;request.setCharacterEncoding(“utf-8”);&gt;<br>注：request.setCharacterEncoding方法无法解决通过URL传递参数所产生的中文乱码问题，可修改Tomcat目录下的conf文件夹下server.xml中&lt;<code>Connector&gt;</code>标签后加入 URLEncoding = “utf-8”</p></blockquote><p>问：用request的getParameterValues获取数组元素并输出。</p><p>在传值页面设置多选项的name一致。比如说都叫favorite。<br>在取值页面用jsp操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    String [] favorites &#x3D; reqquest.getParameterValues(&quot;favorite&quot;);&#x2F;&#x2F;设置string数组接收数组数据。</span><br><span class="line">    for(int i&#x3D;0;i&lt;favorites.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        out.println(favorites[i]+&quot;&amp;nbsp;&amp;nbsp;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>Ps1：String getParameter(String name)//获取单个参数值<br>Ps2：String[] getParameterValues(String name)//获取多个参数值，如获取checkbox的值<br>Ps3：request.setCharacterEncoding(“utf-8”);//解决post请求传递中文参数的乱码问题，设置的编码要与发送请求的页面的编码设置的一致。但是无法解决URL链接传递中文参数的乱码问题<br>Ps4：tomcat/conf/server.xml;//解决get请求和URL链接传递中文参数的乱码问题，可将Connector的URIEncoding=“UTF-8”<br>Ps5：href=“request.jsp?user=李四”//里面写值的时候可以不需要引号//所谓的url传参，就是利用get提交的方法拼接一个带参数的url提交给一个接受的jsp页面，这个jsp页面写在最前面，如上</p><h3 id="out对象">out对象</h3><p>一、什么是缓冲区<br>1、缓冲区：Buffer，所谓缓冲区就是内存的一块区域，用来保存临时数据<br>2、IO输出最原始的就是一个字节一个字节输出，效率很低。缓冲区可以先将多个字节读出来，再一次性的输出，提高效率<br>二、out对象<br>1、out对象是JspWriter类的实例，是向客户端（这里指浏览器）输出内容的常用对象。<br>2、常用方法：<br>· void println()向客户端打印字符<br>· void clear()清除缓冲区的内容。如果在flush之后调用，会抛出异常<br>· void clearBuffer() 也是清除缓冲区内容，但在flush之后不会抛出异常<br>· void flush()将缓冲区内容输出到客户端</p><h3 id="JSP内置对象——请求转发与请求重定向的区别">JSP内置对象——请求转发与请求重定向的区别</h3><p>一、请求重定向：服务端response.sendRedirect(“xx.jsp”)重定向。【客户端行为】：即客户端会访问两次，第一次访问后会立即跳转到第二个重定向页面上，【从本质上讲等于两次请求】，而前一次的请求封装的request对象不会保存，地址栏的URL地址会改变。<br>二、请求转发：服务端request.getRequestDispatcher(“xx.jsp”).forward(request,response)请求转发。forward(request,response)用于保存内置对象request和response。【服务器行为】：服务器会代替客户端去访问转发页面，【从本质是一次请求】，转发后请求对象会保存，地址栏的URL地址不会改变。</p><h3 id="什么是session">什么是session</h3><p>1、session表示客户端与服务器的一次会话<br>2、Web中的session指：用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览网站所花费的时间。<br>3、从上述定义中可以看到，session实际是一个【特定的时间概念】<br>4、服务器的内存中，保存着同用户的session。不同的用户有不同的session。</p><h3 id="session的生命周期-活动">session的生命周期 活动</h3><p>某次会话当中通过超链接打开的新页面属于同一次会话<br>只要当前会话页面没有全部关闭，重新打开新的浏览器窗口访问同意项目资源时属于同一次会话。<br>除非本次会话的所有页面都关闭后再重新访问某个新的jsp或者servlet将会创建新的会话。<br>注意事项：<br>注意原有的会话还存在，只是这个旧的sessionId仍然存在于服务器端，只不过再也没有客户端会携带它然后交予服务器端校验<br>session销毁的三种方式：<br>1:调用session.invalidate()方法<br>2：session过期（超时）<br>3;服务器重新启动<br>设置session超时的两种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tomcat默认session超时时间为30分钟</span><br><span class="line">1：session.setMaxInactiveInterval(时间);&#x2F;&#x2F;单位是秒</span><br><span class="line">2:在web.xml配置</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">&lt;session-timeout&gt;</span><br><span class="line">10</span><br><span class="line">&lt;session-timeout&gt;</span><br><span class="line">&lt;session-config&gt; &#x2F;&#x2F;单位是分钟</span><br></pre></td></tr></table></figure><p>一、http协议的无状态性<br>1、无状态是指，当浏览器发送请求给服务器的时候，服务器会响应。但当同一个浏览器再次发送请求时，服务器不会知道是刚才那个浏览器。<br>2、简单说，服务器【不会保存用户状态】，不会记得客户端是否访问过，所以这就是无状态协议</p><p>jsp状态管理<br>保存用户状态的两大机制<br>1、Session<br>2、Cookie<br>什么是cookie？<br>cookie：是web服务器保存在客户端的一系列文本信息。<br>典型应用一：判断注册用户是否已经登录网站。<br>典型应用二：保存用户浏览记录。<br>cookie的作用：<br>1、对特定对象的追踪。<br>2、保存用户网页浏览记录与习惯。<br>3、简化登录<br>安全风险：容易泄露用户信息</p><p>session与cookie对比<br>1.保存位置：session在服务器端内存，cookie在客户端文本<br>2.保存对象：session保存Object类（保存对象大小没有限制），cookie保存String类型（保存对象大小有限制）<br>3.生存权：session会话结束即销毁，cookie可以长期保存在客户端<br>4.重要性：session安全性更高，保存重要信息，cookie保存不重要的信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Jsp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协议栈如何处理数据</title>
      <link href="/2021/07/26/%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/07/26/%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="协议栈如何处理数据">协议栈如何处理数据</h3><p>(1)创建套接字</p><p>从应用程序收到委托后，协议栈通过TCP协议收发数据的操作可以分为4个阶段。首先是创建套接字，在这个阶段，有协议栈的内部结构、套接字的实体，以及创建套接字的操作过程。</p><p>(2)连接服务器</p><p>接下来是客户端套接字向服务器套接字进行连接的阶段。</p><p>(3)收发数据</p><p>两端的套接字完成连接之后，就进人收发消息的阶段了。在这个阶段,协议栈会将从应用程序收到的数据切成小块并发送给服务器，考虑到通信过程中可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送达服务器，对于没有送达的包要重新发送一次。</p><p>(4)从服务器断开连接并删除套接字<br>收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。断开操作的本质是当消息收发完成后客户端和服务器相互进行确认的过程</p><p>(5)IP与以太网的包收发操作<br>在介绍TCP协议收发消息的操作之后，我们再来看看实际的网络包是如何进行收发的。协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。</p><p>(6)用UDP协议收发数据的操作<br>TCP协议有很多方便的功能，比如网络包出错丢失时可以重发，因此很多应用程序都是使用TCP协议来收发数据的，但这些方便的功能也有帮倒忙的时候，在这种情况下我们还有另外一种叫UDP的协议。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2021/07/02/CSS/"/>
      <url>/2021/07/02/CSS/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CSS的引入方式">1.CSS的引入方式</h3><h4 id="a-内联式CSS">a.  内联式CSS</h4><p>把css代码直接写在现有的HTML标签中，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style &#x3D; &quot;color : red ; font-size : 12px&quot;&gt;文本&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h4 id="b-嵌入式CSS">b. 嵌入式CSS</h4><p>就是可以把css样式代码写在style标签之间。如下面代码实现把三个span标签中的文字设置为红色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; span&#123; color:red; &#125; &lt;&#x2F;style&gt; </span><br></pre></td></tr></table></figure><h4 id="c-嵌入式css样式">c.嵌入式css样式</h4><p>必须写在<code>&lt;style&gt;&lt;/style&gt;</code>之间，并且一般情况下嵌入式css样式写在<code>&lt;head&gt;&lt;/head&gt;</code>之间。</p><h4 id="d-外部式CSS">d.外部式CSS</h4><p>外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以“.css”为扩展名，在head标签内（不是在style标签内）使用link标签将css样式文件链接到HTML文件内，如下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href&#x3D;&quot;style.css&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; &#x2F;&gt; </span><br></pre></td></tr></table></figure><p>​         注意： 1、css样式文件名称以有意义的英文字母命名，如 main.css。 2、rel=“stylesheet” type=“text/css” 是固定写法不可修改。 3、<code>&lt;link&gt;标签位置一般写在&lt;head&gt;标签之内</code>。 这三种样式是有优先级的，记住他们的优先级：内联式 &gt; 嵌入式 &gt; 外部式，但是嵌入式 &gt; 外部式有一个前堤：嵌入式CSS样式的位置一定在外部式的后面。 其实总结来说就是–就近原则(离被设置元素越近优先级越高)。 但注意上面所总结的优先级是有一个前提:内联式，嵌入式，外部式样式表中CSS样式相同权值的情况下。</p><h3 id=""></h3><h3 id="2-CSS中的盒子模型">2.CSS中的盒子模型</h3><h4 id="a-盒子模型中主要的区域：">a.<strong>盒子模型中主要的区域：</strong></h4><p>盒子模型（块级元素）中主要包含元素的宽，高，外边距，边框，内边距以及实际内容。</p><ul><li>Width：主要区域的内容（content）的宽。</li><li>Height：主要区域的内容（content）的宽。</li><li>Margen：外边距。即整个元素和其他元素的距离。</li><li>Border：元素的边框。</li><li>Padding：内边距。即元素的边与内容的距离。</li><li>Content：内容。也就是实际所看到的区域。</li></ul><p>下面的图片说明了盒子模型的区域：</p><p><img src="/img/pg/1350478-20180318130200144-1334747621.gif" alt="img"></p><p>盒子模型的宽度、高度的计算</p><p>而我们平常设置盒子的宽和高往往是指的内容的宽和高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;width:200px; height:18px;&#125;</span><br></pre></td></tr></table></figure><p>此段话代表content所占大小为宽200像素，高为18像素；</p><p>而当我们增加其他三个属性时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">width:200px;</span><br><span class="line">height:18px;</span><br><span class="line">padding:20px;</span><br><span class="line"> border:1px solid red;</span><br><span class="line">margin:10px; &#125;</span><br></pre></td></tr></table></figure><p>效果图为：</p><p><img src="/img/pg/20180716195205144" alt="img"></p><p>所以说当改变盒子四个属性中的任何一个的时候，盒子的总面积都会有所改变。</p><p>最后，盒子总大小的计算公式为：盒子的实际高度X盒子的实际宽度。</p><p><strong>元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</strong></p><p><strong>元素实际宽度（盒子的高度）=上边界+上边框+上填充+内容高度+下填充+下边框+下边界。</strong></p><h4 id="b-盒子模型注意事项">b.盒子模型注意事项</h4><p>​    需注意margin是用来隔开元素与元素的间距;padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不干扰;padding用于元素与内容之间的间隔，让内容与元素之间有一段距离。</p><p>当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充。</p><p>单独使用 padding 属性可以改变上下左右的填充。</p><p><img src="/img/pg/VlwVi.png" alt="img"></p><h4 id="c-css什么时候需要清除浮动？">c.<strong>css什么时候需要清除浮动？</strong></h4><p>当父元素没有设置宽度或者高度的时，又需要子元素撑开父元素的时候需要清除浮动。</p><p>如何清除浮动</p><p>我们说的清除浮动是指清除由于子元素浮动带来父元素高度塌陷的影响。</p><p>解决子盒子浮动父盒子塌陷的问题：</p><p>1.给父盒子添加overflow：hidden属性。[常用]</p><p>2.让父盒子也浮动（前提是父盒子的宽度为100%）。</p><p>3.在父容器的最后添加一个高度为0的空div并且添加clear：both属性。</p><p>4.使用伪对象选择器：：after生成一个空的元素</p><h4 id="d-块级元素">d.块级元素</h4><ol><li><p>标准流模型中的块级盒子，默认宽度是100%；而浮动的块级盒子，宽度不会自动伸展，而是由内容(文字、padding)撑开。浮动后的行级元素会变成块级元素， 可以设置宽度高度等属性值。</p></li><li><p>text-align: center;文字水平居中。 line-height:（与div设置的高度相同）；垂直居中,因为line-height是行高属性，比如设置这个属性高度为35px，你的字体就会被安放在这个高度的中间高度显示，就像居中一样</p></li><li><p>设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。a{display:block;}</p></li></ol><p>块级元素特点：</p><p>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><p>3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript</title>
      <link href="/2021/06/14/Javascript/"/>
      <url>/2021/06/14/Javascript/</url>
      
        <content type="html"><![CDATA[<p>1.一些html标签、事件的含义</p><p>如：<div id="aa">这是内容</div></p><p>我们可以通过 document.getElementById(‘aa’).innerHTML 来获取id为aa的对象的内嵌内容；<br>也可以对某对象插入内容，如 document.getElementById(‘abc’).innerHTML=’这是被插入的内容’;</p><p>2.一些注意事项</p><p>（1）对字符串和数字进行加法运算</p><p>​     如果两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串。</p><p>（2）Undefined 和 Null</p><p>Undefined 这个值表示变量不含有值。可以通过将变量的值设置为 null 来清空变量。这两者的值相等，但数据类型不相同，所以并不绝对相等。</p><p>​    （3）在 JavaScript中，几乎所有的事物都是对象。javaScript 对象是键值对的容器，“键”必须为字符串，“值” 可以是 JavaScript 中包括 null 和 undefined 的任意数据类型。</p><p>对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 <strong>name:value</strong> 对呈现。</p><blockquote><p>var car = {name:“Fiat”, model:500, color:“white”};</p></blockquote><p>在以上实例中，3 个值 (“Fiat”, 500, “white”) 赋予变量 car。JavaScript 对象是变量的容器。</p><p>（4）javaScript对象:属性和方法的容器;</p><p>对象的属性之间一定要用逗号隔开;</p><p>对象的方法定义了一个函数，并作为对象的属性存储。</p><p>对象方法通过添加 <strong>()</strong> 调用 (作为一个函数)。</p><p>（5）assign(url):跳转到指定页面；</p><p>reload(true):刷新当前页面；</p><p>replace(url):用指定网址覆盖当前网页；</p><p>assign()和replace()的区别你可以理解为前者是打开新的页面，后者是覆盖原有页面</p><p>（6）Date对象方法中getDay() 方法可返回表示星期的某一天的数字。返回值是 0（周日） 到 6（周六） 之间的一个整数。getDate()获取当日日期</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown-it渲染器测试</title>
      <link href="/2021/06/03/markdown-it%E6%B8%B2%E6%9F%93%E5%99%A8%E8%A1%A8%E6%83%85%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/06/03/markdown-it%E6%B8%B2%E6%9F%93%E5%99%A8%E8%A1%A8%E6%83%85%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-表情">1.  表情</h3><h4 id="1-正常文本间的表情">1.正常文本间的表情</h4><p>看在文字间的情况:art:看在文字间的情况</p><h4 id="2-引用块中的表情">2.引用块中的表情</h4><blockquote><p>:grin:</p><p>:fire:</p></blockquote><hr><h3 id="2-hexo渲染测试">2.hexo渲染测试</h3><h4 id="1-测试HTML">1.测试HTML</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;这是div&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>这是div</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组注意事项</title>
      <link href="/2021/05/31/%E8%AE%A1%E7%BB%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2021/05/31/%E8%AE%A1%E7%BB%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念">基本概念</h3><h4 id="位-bit">位(bit)</h4><p><strong>位是电子计算机中最小的数据单位</strong>。每一位的状态只有两种：0或1，在硬件上利用高电压和低电压两种信号实现；</p><h4 id="字节-Byte-B">字节(Byte, B)</h4><p><strong>字节由</strong>8个位组成，它是存储空间的基本计量单位；</p><h4 id="字">字</h4><p>字由若干个字节组成。因此，字一定为字节的整数倍。字的位数称为字长（注意：字不等于字长乘以字节！字=字长×位）。比如一个8位的CPU，这里的8位指其字长为8位，即单位时间内可以处理8位二进制数，即一个字节数。现在的CPU大部分为64位，即单位时间内可以处理64位二进制数，即8个字节数；</p><h4 id="地址线">地址线</h4><p>用于传输地址信息的数据线，一根地址线可以通过高电平或低电平来区分1或0，因此一根地址线有两个状态：1或0，那么N根地址线可以表示2的n次个不同的状态。（也表示寻址范围)</p><h3 id="寻址范围的计算">寻址范围的计算</h3><h4 id="按字节寻址">按字节寻址</h4><p>寻址范围与地址线根数有关，若有n根地址线，则寻址大小为<strong>2的n次</strong></p><blockquote><p>设有一个1MB容量的存储器，字长32位，问：按字节编址，字编址的寻址范围以及各自的寻址范围大小?</p><p>如果按字节编址，则</p><p>​                 1MB = 2^20B</p><p>​                 1字节=1B=8bit</p><p>​                 2^20B/1B = 2^20</p><p>地址范围为0~(2^20)-1,也就是说需要二十根地址线才能完成对1MB空间的编码，所以地址寄存器为20位,寻址范围大小为2^20=1M</p></blockquote><h4 id="按字寻址">按字寻址</h4><p>寻址和地址线根数，字长有关，若有n根，字长为32位（4个字节),则寻址大小为<strong>2的n次方除以4</strong></p><blockquote><p>如果按字编址，则</p><p>​                  1MB=2^20B</p><p>​                  1字=32bit=4B</p><p>​                 2^20B/4B = 2^18</p><p>地址范围为0~2^18-1，也就是说我们至少要用18根地址线才能完成对1MB空间的编码。因此按字编址的寻址范围是2^18</p></blockquote><blockquote><p>某计算机字长为32，其存储容量为16MB，若按双字编址，它的寻址范围是多少</p><p>按双字变址，故为64位<br>16MB=16<em>1024</em>1024<em>8位，所以16MB可以寻址为：<br>(16</em>1024<em>1024</em>8)/64=2<em>1024</em>1024=2M,</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之路</title>
      <link href="/2021/05/28/java%E4%B9%8B%E8%B7%AF/"/>
      <url>/2021/05/28/java%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/pg/java%E5%AD%A6%E4%B9%A0.png" alt="java学习"></p><p>1.Javascript/html/css基础语法    完成(待提升)</p><ol start="2"><li>BootStrap基础使用了解          完成</li><li>计算机网络基础知识</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广佛游记</title>
      <link href="/2021/05/15/%E5%B9%BF%E4%BD%9B%E6%B8%B8%E8%AE%B0/"/>
      <url>/2021/05/15/%E5%B9%BF%E4%BD%9B%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>——广州——<br>广州作为中国最早开放的城市之一，有些深厚的历史文化底蕴，你可以看到它现代和复古的美丽<br>在来广州之前做足了攻略:fire:，听说沙面是拍照的好景点，第一站就来到了这－沙面</p><p><img src="/img/pg/3163559_e525fce9_1207_2187@2312x2312.jpeg.m.jpg" alt="img"></p><p>沙面</p><p>这附近有着不少的旧式风格的建筑，确实是拍照的好地方（漂亮小姐姐也挺多的!），不少人都带着专业的摄像机。</p><p><img src="/img/pg/3163559_9f240a5c_1207_2189@2312x2312.jpeg.m.jpg" alt="img"></p><p>这好像是在织布</p><p>之后来到了圣心大教堂，或许是五一游客太多，为了限制人流，现在只有教徒凭票才能进去，普通游客不能进去。</p><p><img src="/img/pg/3163559_20e37df3_1207_2191@2312x2312.jpeg.m.jpg" alt="img"></p><p>来到了广州，肯定要看的是俗称“小蛮腰”的广州塔啦。</p><p><img src="/img/pg/3163559_e2d2653f_1207_2195@2312x2312.jpeg.m.jpg" alt="img"></p><p>广州大剧院</p><p>由于我是在五一晚上，你们懂得，一眼望去全是人从众，人实在是多的受不了，所以我取消了第二天晚上登上广州塔的预约，挺遗憾的。最后还是本地的士兵们执勤帮忙疏散人群（辛苦士兵们了），很多辆公交车也被派出运送游客。</p><p><img src="/img/pg/3163559_cb4765ec_1207_2197@2312x2312.jpeg.m.jpg" alt="img"></p><p>“小蛮腰”－广州塔</p><p>——佛山——<br>佛山是武术之乡，这里有着叶问，黄飞鸿等一代武术大师。<br>祖庙是当地有名的旅游景点，这地方挺大的，花了挺多时间游玩</p><p><img src="/img/pg/3163559_39812ff5_1207_2199@2312x2312.jpeg.m.jpg" alt="img"></p><p>园林风格</p><p><img src="/img/pg/3163559_96c0880d_1207_2202@2312x2312.jpeg.m.jpg" alt="img"></p><p>在这你也可以看到园林风格的美。</p><p><img src="/img/pg/3163559_1fe6304b_1207_2208@2122x2122.jpeg.m.jpg" alt="img"></p><p>许愿池</p><p>这许愿池真的好多乌龟，（话说这石像是玄武吗），不少游客向其中投入硬币，祈求愿望。</p><p><img src="/img/pg/3163559_c2612488_1207_2212@2312x2312.jpeg.m.jpg" alt="img"></p><p>有关黄飞鸿电影画面的图片</p><p>在祖庙里有着黄飞鸿纪念馆，介绍了武术大师黄飞鸿的生平。这附近甚至也有以他命名的步行街。</p><p><img src="/img/pg/3163559_1c968e51_1221_1779@2312x2312.jpeg.m.jpg" alt="img"></p><p>一条美食街</p><p>同样一代宗师叶问的纪念馆也坐落于祖庙，在馆前你能免费拍照，得到一张6寸照。<br>来到广东，美食也是必须尝试的啦，姜撞奶，双皮奶，糖水类等都值得尝试，比较出名的店有辉记甜品店，但人有点多</p><p><img src="/img/pg/3163559_60b276c3_1221_1781@2312x2312.jpeg.m.jpg" alt="img"></p><p>一下吃多了龟苓膏会觉得有点苦</p><p><img src="/img/pg/3163559_19b70b01_1221_1783@2312x2312.jpeg.m.jpg" alt="img"></p><p>吃起来觉得有点辣</p><p>（第一次写图文，排版有点差），大概就这些啦。<a href="https://www.coolapk.com/feed/26716729?shareKey=MzU1MmQxNzQ0OTNlNjA5ZjFkNDM~&amp;shareUid=3163559&amp;shareFrom=com.coolapk.market_11.1.5.1">转自酷安</a></p>]]></content>
      
      
      <categories>
          
          <category> 生活派 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shop system</title>
      <link href="/2021/04/11/shop-system/"/>
      <url>/2021/04/11/shop-system/</url>
      
        <content type="html"><![CDATA[<ul><li><p>​    <strong>预知</strong>：Java项目中大致分为三层：</p><p>【1】<strong>控制层</strong>（controller）的职能是负责读取视图表现层的数据，控制用户的输入，并调用业务层的方法；</p><p>【2】<strong>业务层</strong>（service）需要根据系统的实际业务需求进行逻辑代码的编写，有些业务逻辑需要通过与数据库交互的，则业务逻辑层需要调用数据访问层的相关方法实现与数据库的交互，</p><p>【3】<strong>数据访问层</strong>（dao）只负责与数据库的数据交互，将数据进行存储读取操作</p><p>【注释；表现层就是看到的东西，比如你现在看到的当前页面<br>控制层就将你的请求从页面传到后台代码<br>逻辑层就是处理你的请求的代码<br>DAO层就是将数据存到数据库中的代码】</p></li><li><p><strong>项目需求：</strong></p><p>为了便于超市业务的管理而设计的该超市管理系统。</p></li><li><p><strong>功能模块：</strong></p><p>该系统有客户信息管理，购物结算，客户回馈等基本功能</p></li><li><p><strong>项目流程图</strong>：</p><p><img src="/img/pg/shop-system.png" alt="shop-system "></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库中的注意事项</title>
      <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="数据库连接问题"><strong>数据库连接问题</strong></h4><h5 id="解决方法">解决方法</h5><p>​      在导入idea项目后，尝试连接数据库，即使账号密码正确，但连接仍一直失败，报错提示:”error no. 1045 access denied for user ‘root’@‘*****’ (using password:YES)。“ 网上查询得知mysql默认root账号只允许本机(localhost, 127.0.0.1)来连接访问. 因此可采取如下方法解决。</p><blockquote><p>运行  mysql -u root -p</p><p>​               use mysql；</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root’@‘%’ IDENTIFIED BY ‘123456’</p><p>​                 这里的123456为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址。</p><p>lush privileges;      这一步一定要做，不然无法成功！ 这句表示从mysql数据库的grant表中重新加载权限数据</p><p>​              因为MySQL把权限都放在了cache中，所以在做完更改后需要重新加载。</p></blockquote><h5 id="声明">声明</h5><p>一般在一个方法或类的声明处通过throws声明方法或类中可能抛出的异常，而在方法或类内部一般通过throw声明一个准实的异常信息。</p><hr><h4 id=""></h4><h4 id="数据库的部分依赖，完全依赖，传递依赖以及三种范式"><strong>数据库的部分依赖，完全依赖，传递依赖以及三种范式</strong></h4><h5 id="依赖关系">依赖关系</h5><ol><li><strong>部分函数依赖</strong>：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</li></ol><blockquote><p>举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。</p></blockquote><p><strong>完全函数依赖</strong>：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</p><blockquote><p>举个例子：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB.</p></blockquote><p><strong>传递函数依赖</strong>：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p><blockquote><p>举个例子：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A</p></blockquote><h5 id="三种范式"><strong>三种范式</strong></h5><h6 id="1-、第一范式（1NF）">1 、第一范式（1NF）</h6><p>​      在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。<br>所谓第一范式（1NF）是指数据库表的每一列(即每个属性)都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。<strong>简而言之，第一范式就是无重复的列。</strong></p><h6 id="2、-第二范式（2NF）">2、 第二范式（2NF）</h6><p>​    第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。<strong>简而言之，第二范式就是非主属性依赖于主关键字。</strong></p><h6 id="3-、第三范式（3NF）">3 、第三范式（3NF）</h6><p>​     满足第三范式（3NF）必须先满足第二范式（2NF）。在满足第二范式的基础上，切不存在传递函数依赖，那么就是第三范式。<strong>简而言之，第三范式就是属性不依赖于其它非主属性。</strong></p><p><strong>简而言之</strong><br><strong>1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。</strong></p><p><strong>2、第二范式（2NF）：满足第一范式，然后消除部分依赖。</strong></p><p><strong>3、第三范式（3NF）： 满足第二范式，消除传递依赖。</strong></p><p><strong>4、BC范式：满足第三范式，只有码在起决定作用。</strong></p><hr><h4 id="关系模型中各种键的定义和区别"><strong>关系模型中各种键的定义和区别</strong></h4><p><strong>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键</strong></p><p><strong>候选键(candidate key):不含有多余属性的超键称为候选键</strong></p><p><strong>主键(primary key):用户选作元组标识的一个候选键程序主键</strong></p><p>比如一个小范围的所有人，没有重名的，考虑以下属性</p><p>身份证 姓名 性别 年龄</p><ol><li>超键的组合是唯一的，但可能不是最小唯一的</li></ol><blockquote><p>身份证唯一，所以是一个超键</p><p>姓名唯一，所以是一个超键</p><p>（姓名，性别）唯一，所以是一个超键</p><p>（姓名，性别，年龄）唯一，所以是一个超键</p></blockquote><p>2.主键是选中的一个候选键</p><blockquote><p>身份证唯一，而且没有多余属性，所以是一个候选键</p><p>姓名唯一，而且没有多余属性，所以是一个候选键</p></blockquote><ol start="3"><li>主键是选中的一个候选键</li></ol><blockquote><p>考虑输入查询方便性，可以选择 身份证 为主键</p><p>也可以 考虑习惯 选择 姓名 为主键</p></blockquote><p><strong>主属性：候选码的中的一个属性。</strong></p><blockquote><p>选课（学号，课程号），此关系的候选码只有一个，为：【学号、课程号】，故主属性有：学号、课程号</p></blockquote><hr><h4 id="求出关系模式的候选键">求出关系模式的候选键</h4><p>[算法]：按以下步骤求候选键：<br>1.只在FD右部出现的属性，不属于候选码;<br>2.只在FD左部出现的属性，一定存在于某候选码当中;<br>3.外部属性一定存在于任何候选码当中;<br>4.其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码。</p><blockquote><p>R&lt;U,F&gt;,U=(A,B,C,D,E,G),F={AB–&gt;C,CD–&gt;E,E–&gt;A.A–&gt;G},求候选码。</p><p>因G只在右边出现,所以G一定不属于候选码;而B,D只在左边出现,所以B,D一定属于候选码;BD的闭包还是BD,则对BD进行组合,除了G以外,BD可以跟A,C,E进行组合<br>先看ABD<br>ABD本身自包ABD,而AB–&gt;C,CD–&gt;E,A–&gt;G,所以ABD的闭包为ABDCEG=U<br>再看BDC<br>CD–&gt;E,E–&gt;A,A–&gt;G,BDC本身自包,所以BDC的闭包为BDCEAG=U<br>最后看BDE<br>E–&gt;A,A–&gt;G,AB–&gt;C,BDE本身自包,所以BDE的闭包为BDEAGC=U</p><p>因为(ABD)、(BCD)、(BDE)的闭包都是ABCDEG所以本问题的候选码有3个分别是ABC、BCD和BDE</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>travel</title>
      <link href="/2021/04/06/travel/"/>
      <url>/2021/04/06/travel/</url>
      
        <content type="html"><![CDATA[<p>久违的踏青，天上也下着小雨，路上没有多少行人，自然中的清新感也扫去了心中的烦闷感<img src="../../../../img/pg/e.jpg" alt="e"></p><p><img src="../../../../img/pg/c.jpg" alt="c"></p><p><img src="../../../../img/pg/d.jpg" alt="d"></p><p><img src="../../../../img/pg/b.jpg" alt="b"></p><p><img src="../../../../img/pg/a.jpg" alt="a"></p><p><img src="../../../../img/pg/f.jpg" alt="f"></p><p><img src="/img/pg/g.jpg" alt="g"></p>]]></content>
      
      
      <categories>
          
          <category> 生活派 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背影</title>
      <link href="/2021/03/28/%E8%83%8C%E5%BD%B1/"/>
      <url>/2021/03/28/%E8%83%8C%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<p>我与父亲不相见已二年余了，我最不能忘记的是他的背影。那年冬天，祖母死了，父亲的差使也交卸了，正是祸不单行的日子。我从北京到徐州，打算跟着父亲奔丧回家。到徐州见着父亲,看见满院狼藉的东西，又想起祖母，不禁簌簌地流下眼泪。父亲说，“事已如此，不必难过，好在天无绝人之路!”回家变卖典质，父亲还了亏空;又借钱办了丧事。这些日子，家中光景很是惨淡，一半为了丧事，一半为了父亲赋闲。丧事完毕，父亲要到南京谋事，我也要回北京念书，我们便同行。</p><p>到南京时，有朋友约去游逛，勾留了一日;第二日上午便须渡江到浦口，下午上车北去。父亲因为事忙，本已说定不送我，叫旅馆里一个熟识的茶房陪我同去。他再三嘱咐茶房，甚是仔细。但他终于不放心，怕茶房不妥帖;然后他颠颇踌躇了一会。其实我那年已二十岁，北京已来往过两三次，是没有什么要紧的了。他踌躇了一会，终于决定还是自己送我去。我再三回劝他不必去;他只说，“不要紧，他们去不好!”</p><p>我们过了江，进了车站。我买票，他忙着照看行李。行李太多了，得向脚夫行些小费才可过去。他便又忙着和他们讲价钱。我那时真是聪明过分，总觉他说话不大漂亮，非自己插嘴不可，但他终于讲定了价钱;就送我上车。<img src="/img/pg/1.jpg" alt="1">他给我拣定了靠车门的一张椅子;我将他给我做的紫毛大衣铺好座位。他嘱我路上小心，夜里要警醒些，不要受凉。又嘱托茶房好好照应我。我心里暗笑他的迂;他们只认得钱，托他们只是白托!而且我这样大年纪的人，难道还不能料理自己么?唉，我现在想想，那时真是太聪明了!</p><p>我说道，“爸爸，你走吧。”他往车外看了看说，“我买几个橘子去。你就在此地，不要走动。”我看那边月台的栅栏外有几个卖东西的等着顾客。走到那边月台，须穿过铁道，须跳下去又爬上去父亲是一个胖子，走过去自然要费事些。我本来要去的，他不肯，只好让他去。我看见他戴着黑布小帽，穿着黑布大马褂，深青布棉袍，蹒跚地走到铁道边，慢慢探身下去，尚不大难。可是他穿过铁道，要爬上那边月台，就不容易了。他用两手攀着上面，两脚再向上缩;他肥胖的身子向左微倾，显出努力的样子。这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪。怕他看见，也怕别人看见。我再向外看时，他已抱了朱红的橘子往回走了。过铁道时，他先将橘子散放在地上，自己慢慢爬下，再抱起橘子走。到这边时，我赶紧去搀他。他和我走到车上，将橘子一股脑儿放在我的皮大衣上。<img src="/img/pg/2.jpg" alt="2">于是扑扑衣上的泥土，心里很轻松似的。过一会儿说，“我走了，到那边来信!”我望着他走出去。他走了几步，回过头看见我，说，“进去吧，里边没人。”等他的背影混入来来往往的人里，再找不着了，我便进来坐下，我的眼泪又来了。</p><p>近几年来，父亲和我都是东奔西走，家中光景是一日不如一日。他少年出外谋生，独力支持，做了许多大事。哪知老境却如此颓唐!他触目伤怀，自然情不能自已。情郁于中，自然要发之于外;家庭琐屑便往往触他之怒。他待我渐渐不同往日。但最近两年不见，他终于忘却我的不好，只是惦记着我，惦记着我的儿子。我北来后，他写了一信给我，信中说道：“我身体平安，唯膀子疼痛厉害，举箸提笔，诸多不便，大约大去之期不远矣。”我读到此处，在晶莹的泪光中，又看见那肥胖的、青布棉袍黑布马褂的背影。唉!我不知何时再能与他相见</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
