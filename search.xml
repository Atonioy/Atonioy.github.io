<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mybatis(三)分页和注解开发</title>
      <link href="/2022/02/12/Mybatis-%E4%B8%89-%E5%88%86%E9%A1%B5%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
      <url>/2022/02/12/Mybatis-%E4%B8%89-%E5%88%86%E9%A1%B5%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis（二）CRUD和配置文件解析</title>
      <link href="/2022/01/26/MyBatis%EF%BC%88%E4%BA%8C%EF%BC%89CRUD%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/01/26/MyBatis%EF%BC%88%E4%BA%8C%EF%BC%89CRUD%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="CRUD">CRUD</h2><h3 id="namespace">namespace</h3><p>namespace中的包名要和 Dao/mapper 接口的包名一致！</p><h3 id="select">select</h3><p>选择，查询语句;</p><ul><li>id : 就是对应的namespace中的方法名；</li><li>resultType：Sql语句执行的返回值！</li><li>parameterType ： 参数类型！</li></ul><ol><li><p>编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据ID查询用户</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>编写对应的mapper中的sql语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Insert">Insert</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对象中的属性，可以直接取出来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="keyword">int</span> res = mapper.addUser(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">&quot;zhiyuan&quot;</span>, <span class="string">&quot;212313&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update">update</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125;  where id = #&#123;id&#125; ;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Delete">Delete</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li><p>增删改需要提交事务！</p><p>sqlSession.commit();</p></li></ul><h3 id="分析错误">分析错误</h3><ul><li>标签不要匹配错</li><li>resource 绑定mapper，需要使用路径！</li><li>程序配置文件必须符合规范！</li><li>NullPointerException，没有注册到资源!</li><li>输出的xml文件中存在中文乱码问题！</li><li>maven资源没有导出问题！</li></ul><h3 id="万能Map">万能Map</h3><p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//万能的Map</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    用map集合的方式插入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id,name,pwd) values (#&#123;userid&#125;,#&#123;username&#125;,#&#123;passWord&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用map的形式插入数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userid&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&quot;passWord&quot;</span>,<span class="string">&quot;2222333&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;map&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = mapper.addUser2(map);</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map传递参数，直接在sql中取出key即可！ 【parameterType=“map”】</p><p>对象传递参数，直接在sql中取对象的属性即可！【parameterType=“Object”】</p><p>只有一个基本类型参数的情况下，可以直接在sql中取到！</p><p>多个参数用Map，<strong>或者注解！</strong></p><h3 id="思考题">思考题</h3><p>模糊查询怎么写？</p><p>有两种方式</p><ul><li>Java代码执行的时候，传递通配符 % %</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;%李%&quot;</span>);</span><br></pre></td></tr></table></figure><p>这是我们指定查询<code>&quot;%李%&quot;</code>，如果放个参数获取，这种方式则不能避免sql注入问题</p><ul><li>在sql拼接中使用通配符！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br></pre></td></tr></table></figure><p>推荐使用这种方法</p><hr><h2 id="配置解析">配置解析</h2><h3 id="1、核心配置文件">1、核心配置文件</h3><ul><li><p>mybatis-config.xml</p></li><li><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">properties（属性）</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）</span><br></pre></td></tr></table></figure></li></ul><h3 id="环境配置（environments）">环境配置（environments）</h3><p>MyBatis 可以配置成适应多种环境</p><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p><p>如果要想再连接其它数据库，则需要重新再写个MybatisUtils工具类</p><p>学会使用配置多套运行环境！</p><p>Mybatis默认的事务管理器就是 JDBC ， 连接池 ： POOLED</p><h3 id="属性（properties）">属性（properties）</h3><p>我们可以通过properties属性来实现引用配置文件</p><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</p><p><img src="/img/pg/1569656528134.png" alt="1569656528134"></p><p>编写一个配置文件db.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>在核心配置文件中映入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11111&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以直接引入外部文件</li><li>可以在其中增加一些属性配置</li><li>如果两个文件有同一个字段，优先使用外部配置文件的！</li></ul><h3 id="类型别名（typeAliases）">类型别名（typeAliases）</h3><ul><li>类型别名是为 Java 类型设置一个短的名字。‘</li><li>存在的意义仅在于用来减少类完全限定名的冗余。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以给实体类起别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><p>扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以给实体类起别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.oddfar.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实体类比较少的时候，使用第一种方式。</p><p>如果实体类十分多，建议使用第二种。</p><p>第一种可以自定义别名，第二种则不行（别名为文件名），如果非要改，需要在实体上增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="设置">设置</h3><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p><p><img src="/img/pg/1569657659080.png" alt="1569657659080"></p><p><img src="../img/pg/1569657672791.png" alt="1569657672791"></p><h3 id="其他配置">其他配置</h3><ul><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）(opens new window)</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）(opens new window)</a></li><li>plugins插件<ul><li>mybatis-generator-core</li><li>mybatis-plus</li><li>通用mapper</li></ul></li></ul><h3 id="映射器（mappers）">映射器（mappers）</h3><p>MapperRegistry：注册绑定我们的Mapper文件；</p><p>方式一： 【推荐使用】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/oddfar/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：使用class文件绑定注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.oddfar.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>接口和他的Mapper配置文件必须同名！</li><li>接口和他的Mapper配置文件必须在同一个包下！</li></ul><p>方式三：使用扫描包进行注入绑定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.oddfar.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>接口和他的Mapper配置文件必须同名！</li><li>接口和他的Mapper配置文件必须在同一个包下！</li></ul><p>练习时间：</p><ul><li>将数据库配置文件外部引入</li><li>实体类别名</li><li>保证UserMapper 接口 和 UserMapper .xml 改为一致！并且放在同一个包下！</li></ul><h3 id="生命周期和作用域">生命周期和作用域</h3><p><img src="/img/pg/1569660357745.png" alt="1569660357745"></p><p>生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p><p><strong>SqlSessionFactoryBuilder：</strong></p><ul><li>一旦创建了 SqlSessionFactory，就不再需要它了</li><li>局部变量</li></ul><p><strong>SqlSessionFactory：</strong></p><ul><li>说白了就是可以想象为 ：数据库连接池</li><li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例。</strong></li><li>因此 SqlSessionFactory 的最佳作用域是应用作用域。</li><li>最简单的就是使用<strong>单例模式</strong>或者静态单例模式。</li></ul><p><strong>SqlSession</strong></p><ul><li>连接到连接池的一个请求！</li><li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。</li><li>用完之后需要赶紧关闭，否则资源被占用！</li></ul><p><img src="/img/pg/1569660737088.png" alt="1569660737088"></p><p>这里面的每一个Mapper，就代表一个具体的业务！</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis（一）入门</title>
      <link href="/2022/01/17/Mybatis%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8/"/>
      <url>/2022/01/17/Mybatis%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><h3 id="什么是Mybatis">什么是Mybatis</h3><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong></li><li>它支持定制化 SQL、存储过程以及高级映射。</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li><li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li><li>MyBatis 本是<a href="https://baike.baidu.com/item/apache/6265">apache (opens new window)</a>的一个开源项目<a href="https://baike.baidu.com/item/iBatis">iBatis (opens new window)</a>, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。</li><li>2013年11月迁移到Github。</li></ul><p>如何获得Mybatis？</p><ul><li><p>maven仓库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Github ： <a href="https://github.com/mybatis/mybatis-3/releases">https://github.com/mybatis/mybatis-3/releases</a></p></li><li><p>中文文档：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p></li></ul><h3 id="什么是持久化">什么是持久化</h3><p>数据持久化</p><ul><li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li><li>内存：<strong>断电即失</strong></li><li>数据库(Jdbc)，io文件持久化。</li><li>生活：冷藏. 罐头。</li></ul><p><strong>为什么需要需要持久化？</strong></p><ul><li>有一些对象，不能让他丢掉。</li><li>内存太贵了</li></ul><h3 id="持久层">持久层</h3><p>Dao层，Service层，Controller层….</p><ul><li>完成持久化工作的代码块</li><li>层界限十分明显。</li></ul><h3 id="为甚么需要Mybatis">为甚么需要Mybatis</h3><ul><li>帮助程序猿将数据存入到数据库中。</li><li>方便</li><li>传统的JDBC代码太复杂了。简化。框架。自动化。</li><li>不用Mybatis也可以。更容易上手。</li><li>优点：<ul><li>简单易学</li><li>灵活</li><li>sql和代码的分离，提高了可维护性。</li><li>提供映射标签，支持对象与数据库的orm字段关系映射</li><li>提供对象关系映射标签，支持对象关系组建维护</li><li>提供xml标签，支持编写动态sql。</li></ul></li></ul><h2 id="第一个Mybatis程序">第一个Mybatis程序</h2><p>创建模块<code>mybatis-01</code> 代码文件如下：</p><p><img src="/img/pg/image-20210412205636100.png" alt="image-20210412205636100"></p><p>思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！</p><h3 id="搭建环境">搭建环境</h3><p>搭建数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `mybatis`;</span><br><span class="line"></span><br><span class="line">USE `mybatis`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user`(</span><br><span class="line">  `id` INT(<span class="number">20</span>) NOT NULL PRIMARY KEY,</span><br><span class="line">  `name` VARCHAR(<span class="number">30</span>) DEFAULT NULL,</span><br><span class="line">  `pwd` VARCHAR(<span class="number">30</span>) DEFAULT NULL</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `user`(`id`,`name`,`pwd`) VALUES </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;123890&#x27;</span>)</span><br></pre></td></tr></table></figure><p>新建项目</p><ol><li><p>新建一个普通的maven项目</p></li><li><p>删除src目录</p></li><li><p>导入maven依赖及静态文件导出配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>注：若mysql驱动版本为8.x版本，需要配置mysql时区，还需更改驱动为<code>com.mysql.cj.jdbc.Driver</code></p><h3 id="创建一个模块">创建一个模块</h3><ul><li><p>编写mybatis的核心配置文件</p><p>在<code>resources</code>下添加<code>mybatis-config.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要添加中文注释，把第一行的<code>encoding=&quot;UTF-8&quot;</code>改成<code>encoding=&quot;utf8&quot;</code></p></li><li><p>编写mybatis工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用Mybatis第一步：获取sqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。</span></span><br><span class="line"><span class="comment">     * SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SqlSession</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写代码</p></li><li><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行sql，获取list合集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件</p><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.oddfar.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--select查询语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.oddfar.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="测试">测试</h3><p>核心配置文件中注册 mappers</p><ul><li><p>junit测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步：获得SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一：getMapper</span></span><br><span class="line">    UserDao userDao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">    List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭SqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以能会遇到的问题：</p></li></ul><ol><li><p>配置文件没有注册</p></li><li><p>绑定接口错误。</p></li><li><p>方法名不对</p></li><li><p>返回类型不对</p></li><li><p>Maven导出资源问题</p></li><li><p>没有重写toString方法</p><blockquote><p>任何一个类都是从Object类继承下来的，因此在任何一个类里面都可以重写这个toString()方法。toString()方法的作用是<strong>当一个引用对象和字符串作连接的时候，或者是直接打印这个引用对象的时侯，这个引用对象都会自动调用toString()方法</strong>，通过这个方法返回一个表示引用对象自己正常信息的字符串，而这个字符串的内容由我们自己去定义，默认的字符串内容是“类名+哈希编码”。因此我们可以通过在类里面重写toString()方法，把默认的字符串内容改成我们自己想要表达的正常信息的字符串内容。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础语法</title>
      <link href="/2021/12/06/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/12/06/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java-基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识JAVA</title>
      <link href="/2021/11/30/%E5%88%9D%E8%AF%86JAVA/"/>
      <url>/2021/11/30/%E5%88%9D%E8%AF%86JAVA/</url>
      
        <content type="html"><![CDATA[<h2 id="Java的特性">Java的特性</h2><p><strong>1、跨平台/可移植性</strong></p><p>这是Java的核心优势。Java在设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。</p><p><strong>2、安全性</strong></p><p>Java适合于网络/分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使Java可以很容易构建防病毒，防篡改的系统。</p><p><strong>3、面向对象</strong></p><p>面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于C++为了照顾大量C语言使用者而兼容了C，使得自身仅仅成为了带类的C语言，多少影响了其面向对象的彻底性！</p><p>Java则是完全的面向对象语言。</p><p><strong>4、简单性</strong></p><p>Java就是C++语法的简化版，我们也可以将Java称之为“C+±”。跟我念“C加加减”，指的就是将C++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。</p><p>同时，由于语法基于C语言，因此学习起来完全不费力。</p><p><strong>5、高性能</strong></p><p>Java最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。</p><p>比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使Java程序的执行效率大大提高，</p><p>某些代码甚至接待C++的效率。因此，Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。</p><p><strong>6、分布式</strong></p><p>Java是为Internet的分布式环境设计的，因为它能够处理TCP/IP协议。事实上，通过URL访问一个网络资源和访问本地文件是一样简单的。Java还支持远程方法调用(RMI,Remote Method Invocation)，</p><p>使程序能够通过网络调用方法。</p><p><strong>7、多线程</strong></p><p>多线程的使用可以带来更好的交互响应和实时行为。 Java多线程的简单性是Java成为主流服务器端开发语言的主要原因之一。</p><p><strong>8、健壮性</strong></p><p>Java是一种健壮的语言，吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。</p><p>如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理</p><h2 id="JDK和JRE">JDK和JRE</h2><p><strong>JDK</strong></p><p>Java 2 SDK (Development Kit)包含：JRE的超集，包含编译器和调试器等用于程序开发的文件</p><p><strong>JRE</strong></p><p>Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序和Applet所必须文件</p><p>Java运行环境的三项主要功能：</p><ul><li>加载代码：由class loader 完成；</li><li>校验代码：由bytecode verifier 完成；</li><li>执行代码：由 runtime interpreter完成。</li></ul><p><strong>区别和联系</strong>：</p><p>sdk（也就是jdk）是jre的超集，是在jre的基础上增加了编译器及其他一些开发工具。</p><p>jre就是java运行时环境，包括了jvm和其它一些java核心api,任何一台电脑，只有安装了jre才可以行 java程序.</p><p>如果只是要运行JAVA程序，之需要JRE就可以。 JRE通常非常小，也包含了JVM.</p><p>如果要开发JAVA程序，就需要安装JDK。</p><h2 id="初识JVM">初识JVM</h2><p>JVM是一种规范，可以使用软件来实现，也可以使用硬件来实现，就是一个虚拟的用于执byte-codes 字节码的计算机。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。</p><p>JVM负责将java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。JAVA提供了另一种 解释运行的方法JIT（just in time），可以一次解释完，再运行特定平台上的机器码，高级的JIT可以只能 分析热点代码，并将这些代码转成本地机器码，并将结果缓存起来，下次直接从内存中调用，这样就大 大提高了执行JAVA代码的效率。这样就实现了跨平台、可移植的功能。</p><ol><li><p>JVM是指在一台计算机上由软件或硬件模拟的计算机；它类似一个小巧而高效的CPU。</p></li><li><p>byte-code代码是与平台无关的是虚拟机的机器指令。</p></li><li><p>java字节代码运行的两种方式:</p><ul><li><p>interpreter(解释)</p><p>运行期解释字节码并执行</p></li><li><p>Just-in-time(即时编译)</p><p>由代码生成器将字节代码转换成本机的机器代码,然后可以以较高速度执行。</p></li></ul></li></ol><p>JAVA的跨平台实现的核心是不同平台使用不同的虚拟机</p><p>不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。</p><h2 id="JAVA运行机制">JAVA运行机制</h2><h3 id="编译型语言">编译型语言</h3><p>编译型语言是先将源代码编译成机器语言（机器可以读懂的语言），再由机器运行机器码，这样执行程序的效率比较高。像C和C++就是典型的编译型语言。</p><h3 id="解释型语言">解释型语言</h3><p>其实解释型语言是相对编译型语言存在的，解释型语言是在运行的时候才进行编译，每次运行都需要编译，这样效率比较低。像JavaScript，Python就是典型的解释型语言</p><h3 id="二者的区别">二者的区别</h3><p>简单的举个例子：同样一本英文书，找人翻译成中文版的书然后拿给你看就是编译，找一个翻译员在你旁边给你解读书的含义就是解释。两者各有利弊，编译型语言执行效率高，翻译一次可以多次运行。解释性语言执行效率低，每次运行都需要重新翻译。但是解释型的跨平台性相对要好，比如解释给一个懂中文和解释给一个懂日文的人就叫做兼容性。</p><h3 id="JAVA运行机制-2">JAVA运行机制</h3><p>Java属于两者都有，既有编译过程，又是解释型语言</p><p>Java语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介 于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解 释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以 执行起来比“纯解释型”程序要快许多。</p><p>总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。</p><p>第一步：编译</p><p>利用编译器（javac）将源程序编译成字节码à 字节码文件名：源文件名.class</p><p>第二部：运行</p><p>利用虚拟机（解释器，java）解释执行class字节码文件。</p><p><img src="/img/pg/image-20210319180207773.png" alt="image-20210319180207773"></p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java-基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（五）处理器调度</title>
      <link href="/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/"/>
      <url>/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="处理机调度：调度的概念、时机、切换、过程以及调度方式和基本准则">处理机调度：调度的概念、时机、切换、过程以及调度方式和基本准则</h3><h4 id="调度的概念">调度的概念</h4><h5 id="调度的基本概念">调度的基本概念</h5><p>在多道程序系统中，进程的数量往往多于处理机的个数，进程争用处理机的情况就在所难免。处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、髙效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题。</p><h5 id="调度的层次">调度的层次</h5><p>一个作业从提交开始直到完成，往往要经历以下三级调度，如图2-4所示。</p><ol><li>作业调度。又称高级调度，.其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入/输出设备等必要的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。</li><li>中级调度。又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。</li><li>进程调度。又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</li></ol><h4 id="调度的时机、切换与过程">调度的时机、切换与过程</h4><p>进程调度和切换程序是操作系统内核程序。当请求调度的事件发生后，才可能会运行进程调度程序，当调度了新的就绪进程后，才会去进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，在操作系统内核程序运行时，如果某时发生了引起进程调度的因素，并不一定能够马上进行调度与切换。</p><p>现代操作系统中，不能进行进程的调度与切换的情况有以下几种情况。</p><ol><li>在处理中断的过程中：中断处理过程复杂，在实现上很难做到进程切换，而且<strong>中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</strong></li><li>进程在操作系统内核程序临界区中：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。</li><li>其他需要完全屏蔽中断的原子操作过程中：如加锁、解锁、中断现场保护、恢复等原子操作。<strong>在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</strong></li></ol><p><strong>如果在上述过程中发生了引起调度的条件，并不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。</strong></p><p>应该进行进程调度与切换的情况有：</p><ol><li><p>当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度。</p></li><li><p>当中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。</p></li></ol><p>进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入到当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p><h4 id="进程调度方式">进程调度方式</h4><p>所谓进程调度方式是指当某一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更髙的进程进入就绪队列，此时应如何分配处理机。</p><p>通常有以下两种进程调度方式：</p><ol><li><p>非剥夺调度方式，又称非抢占方式。是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。</p><p>在非剥夺调度方式下，一旦把CPU分配给一个进程，那么该进程就会保持CPU直到终止或转换到等待状态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。</p></li><li><p>剥夺调度方式，又称抢占方式。是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。.</p><p>釆用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有：优先权、短进程优先和时间片原则等。</p></li></ol><h4 id="调度的基本准则">调度的基本准则</h4><ol><li><p>CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU 保持“忙”状态，使这一资源利用率最髙。</p></li><li><p>系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。</p></li><li><p>周转时间。是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处迤机上运行以及进行输入/输出操作所花费时间的总和。</p></li></ol><blockquote><p>周转时间 = 作业完成时间 - 作业提交时间</p><p>平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n</p><p>带权周转时间是指作业周转时间与作业实际运行时间的比值</p><p>平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n</p><p>等待时间=开始时间—提交时间。</p></blockquote><hr><h3 id="操作系统典型调度算法">操作系统典型调度算法</h3><h4 id="先来先服务-FCFS-调度算法">先来先服务(FCFS)调度算法</h4><p>FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。</p><p>在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p><p>在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。</p><p><strong>FCFS调度算法属于不可剥夺算法</strong>。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。</p><p><strong>FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。</strong></p><h4 id="短作业优先-SJF-调度算法">短作业优先(SJF)调度算法</h4><p>短作业（进程）优先调度算法（Shortest Job First ）是指对短作业（进程）优先调度的算法。短<strong>作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</strong>。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p><p>SJF调度算法也存在不容忽视的缺点：</p><ul><li>该算法对长作业不利，SJF调度算法中长作业的周转时间会增加。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些 (即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”。后者是系统环形等待，前者是调度策略问题）。</li><li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。</li><li>由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</li></ul><p><strong>注意，SJF调度算法的平均等待时间、平均周转时间最少。</strong></p><h4 id="优先级调度算法">优先级调度算法</h4><p>优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。</p><p>在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p><p>根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：</p><ul><li>非剥夺式优先级调度算法。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。</li><li>剥夺式优先级调度算法。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。</li></ul><p>而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：</p><ul><li>静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。</li><li>动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。</li></ul><h4 id="高响应比优先调度算法">高响应比优先调度算法</h4><p><strong>高响应比优先调度算法主要用于作业调度</strong>，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p><p>响应比的变化规律可描述为：响应比R=等待时间+要求服务时间/要求服务时间</p><p>根据公式可知：</p><ul><li>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。<br>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</li><li>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</li></ul><h4 id="时间片轮转调度算法">时间片轮转调度算法</h4><p>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。</p><p>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（四）同步与异步的区别</title>
      <link href="/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>1、我们的生活中存在着很多同步异步的例子。</p><p>比如：你叫我去吃饭，我听到了就立刻和你去吃饭，如果我没有听到，你就会一直叫我，直到我听见和你一起去吃饭，这个过程叫同步；异步过程指你叫我去吃饭，然后你就去吃饭了，而不管我是否和你一起去吃饭。而我得到消息后可能立即就走，也可能过段时间再走。如果我请你吃饭，就是同步，如果你请我吃饭就用异步，这样你比较省钱。</p><p>2、在计算机领域</p><p>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；</p><p>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p><p>同步是阻塞模式，异步是非阻塞模式。</p><p>我的理解：同步是指两个线程的运行是相关的，其中一个线程要阻塞等待另外一个线程的运行。异步的意思是两个线程毫无相关，自己运行自己的。</p><p>举个例子：普通B/S模式（同步）AJAX技术（异步）</p><p>同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回  这个期间客户端浏览器不能干任何事</p><p>异步: 请求通过事件触发-&gt;服务器处理（这时浏览器仍然可以作其他事情）-&gt;处理完毕</p><p>当应用程序在对象上调用一个需要花费很长时间来执行的方法的时候，并且不需要让程序等待对方返回，这时就应该使用异步编程。</p><p>3、而我们平时经常讨论的同步问题多发生在多线程环境中的数据共享问题。即当多个线程需要访问同一个资源时，它们需要以某种顺序来确保该资源在某一特定时刻只能被一个线程所访问，如果使用异步，程序的运行结果将不可预料。因此，在这种情况下，就必须对数据进行同步，即限制只能有一个进程访问资源，其他线程必须等待。</p><p>实现同步的机制主要有临界区、互斥、信号量和事件</p><p>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资 源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</p><p>互斥量：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 .互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p><p>信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p><p>事件：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（三）进程同步</title>
      <link href="/2021/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2021/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="进程同步的基本概念：临界资源、同步和互斥">进程同步的基本概念：临界资源、同步和互斥</h3><h4 id="临界资源">临界资源</h4><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p><p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可以把临界资源的访问过程分成四个部分：</p><ul><li>进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li><li>临界区。进程中访问临界资源的那段代码，又称临界段。</li><li>退出区。将正在访问临界区的标志清除。</li><li>剩余区。代码中的其余部分。</li></ul><h4 id="同步">同步</h4><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><p>例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。</p><h4 id="互斥">互斥</h4><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p><p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时, 系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。</p><p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（二）进程和线程</title>
      <link href="/2021/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="进程的概念和特征">进程的概念和特征</h3><h4 id="进程的概念">进程的概念</h4><p>为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为 进程控制块 (Process Control Block, PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。所谓 创建进程，实质上是创建进程映像中的PCB ；而撤销进程，实质上是撤销进程的PCB。值得注意的是， 进程映像是静态的，进程则是动态的 。</p><p>注意：PCB是进程存在的唯一标志！</p><blockquote><p>从不同的角度，进程可以有不同的定义，比较典型的定义有：<br>进程是程序的一次执行过程。<br>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p></blockquote><p><strong>在引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：”进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。“</strong></p><h4 id="进程的特征">进程的特征</h4><p>进程是由多程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。<br>1）动态性：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。<br>2） 并发性：指多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征。<strong>引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。</strong><br>3）独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。<br>4） 异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、 不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制。<br>5） 结构性：每个进程都配置一个PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。</p><hr><h3 id="进程的状态和转换">进程的状态和转换</h3><p>进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化（一个进程会经历若干种不同状态）。通常进程有以下五种状态，运行状态、就绪状态、阻塞状态、创建状态、结束状态。前三种是进程的基本状态。</p><p><strong>注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。</strong></p><p>下图说明了五种进程状态的转换，而三种基本状态之间的转换如下：</p><p><img src="/img/pg/20150921073030742.png" alt="img"></p><p>就绪状态 -&gt; 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。</p><p>运行状态 -&gt; 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</p><p>运行状态 -&gt; 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</p><p>阻塞状态 -&gt; 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</p><hr><h3 id="进程控制：进程的创建、终止、阻塞、唤醒和切换">进程控制：进程的创建、终止、阻塞、唤醒和切换</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为原语，<strong>原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</strong></p><h4 id="进程的创建">进程的创建</h4><p>允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。</p><p>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。</p><h4 id="进程的终止">进程的终止</h4><p>引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。异常结束是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</p><h4 id="进程的阻塞和唤醒">进程的阻塞和唤醒</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</p><h4 id="进程切换">进程切换</h4><p>对于通常的进程，其创建、撤销以及要求由系统设备完成的I/O操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。</p><blockquote><p>注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。如果进程因中断或异常进入到核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的CPU现场，无需改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p></blockquote><hr><h3 id="进程的通信：共享存储、消息传递和管道通信">进程的通信：共享存储、消息传递和管道通信</h3><p>进程通信是指进程之间的信息交换。PV操作（通过、释放）是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。<br>1.共享存储<br>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。</p><p>需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。<br>2.消息传递<br>在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p><p>1）直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</p><p>2）间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。</p><p>3.管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p><hr><h3 id="线程的概念和多线程模型">线程的概念和多线程模型</h3><p><strong>引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；</strong><br><strong>而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</strong></p><p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p><p><strong>引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理机的分配单元。</strong></p><h4 id="线程与进程的比较">线程与进程的比较</h4><ol><li><p>调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p></li><li><p>拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源），但线程可以访问其隶属进程的系统资源。</p></li><li><p>并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。</p></li><li><p>系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、 I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预。</p></li><li><p>地址空间和其他资源（如打开的文件）：进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</p></li><li><p>通信方面：进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p></li></ol><h4 id="线程的属性">线程的属性</h4><p>在多线程操作系统中，把线程作为独立运行（或调度）的基本单位，此时的进程，已不再是一个基本的可执行实体。但进程仍具有与执行相关的状态，所谓进程处于“执行”状态，实际上是指该进程中某线程正在执行。线程的主要属性如下：</p><ol><li>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。</li><li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为它们创建成不同的线程。</li><li>同一进程中的各个线程共享该进程所拥有的资源。</li><li>线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务则可缩短进程的处理时间。</li><li>—个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（一）概述</title>
      <link href="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是操作系统">什么是操作系统</h3><p>操作系统是控制软硬件及方便用户使用的程序集合，目的是方便用户，提高资源利用率。操作系统是一种系统软件，是软、硬件资源的控制中心。</p><hr><h3 id="操作系统的基本特征">操作系统的基本特征</h3><p>操作系统的基本特征包括并发、共享、虚拟和异步。</p><h4 id="并发-Concurrence">并发(Concurrence)</h4><p>并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统 中，引入进程的目的是使程序能并发执行。</p><p>注意同一时间间隔（并发）和同一时刻（并行）的区别。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每一时刻，单处理机环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。橾作系统的并发性是通过分时得以实现的。</p><p>注意，并行性是指系统具有可以同时进行运算或操作的特性，在同一时刻完成两种或两种以上的工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。</p><h4 id="共享（Sharing">共享（Sharing)</h4><p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为以下两种资源共享方式：</p><ol><li>互斥共享方式<br>系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源。</li></ol><p>把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。<br>2) 同时访问方式<br>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即 “分时共享”。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p><p>并发和共享是操作系统两个最基本的特征，这两者之间又是互为存在条件的：<br>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；<br>若系统不能对资源共享实施有效的管理，也必将影响到程序的并发执行，甚至根本无法并发执行。</p><h4 id="虛拟（Virtual">虛拟（Virtual)</h4><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备等。</p><p>在虚拟处理器技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU)在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的CPU,称为虚拟处理器。</p><p>因此，操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器</p><h4 id="异步-Asynchronism">异步(Asynchronism)</h4><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误 (就像对全局变量的访问顺序不当会导致程序出错一样）。但是只要运行环境相同，操作系统必须保证多次运行进程，都获得相同的结果。</p><hr><h3 id="操作系统目标和功能">操作系统目标和功能</h3><p>为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：处理机管理、 存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p><hr><h3 id="操作系统的运行机制">操作系统的运行机制</h3><p>计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序；另一种是用户自编程序或系统外层的应用程序。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”要执行一些特权指令，而“被管理程序”出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如I/O指令、 置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等指令。操作系统在具体实现上划分了用户态（目态）和核心态（管态)，以严格区分两类程序。</p><p>内核是计算机上配置的底层软件，是计算机功能的延伸。不同系统对内核的定义稍有区别，大多数操作系统内核包括四个方面的内容。</p><h4 id="时钟管理">时钟管理</h4><p>在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。诸如，在分时操作系统中，釆用时间片轮转调度的实现；在实时系统中，按截止时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于时钟。</p><h4 id="中断机制">中断机制</h4><p>引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。</p><p>中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</p><h4 id="原语">原语</h4><p>按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。其特点是：<br>它们处于操作系统的最底层，是最接近硬件的部分。<br>这些程序的运行具有原子性——其操作只能一气呵成（这主要是从系统的安全性和便于管理考虑的）。<br>这些程序的运行时间都较短，而且调用频繁。</p><p>通常把具有这些特点的程序称为原语（Atomic Operation)。定义原语的直接方法是关闭中断，让它的所有动作不可分割地进行完再打开中断。</p><p>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可以定义为原语，使它们成为内核的组成部分。</p><h4 id="系统控制的数据结构及处理">系统控制的数据结构及处理</h4><p>系统中用来登记状态信息的数据结构很多，比如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下三种：<br>进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等。<br>存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。<br>设备管理：缓冲区管理、设备分配和回收等。</p><p>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。</p><hr><h3 id="中断和异常的概念">中断和异常的概念</h3><p>​           在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换。操作系统内核工作在核心态，而用户程序工作在用户态。但系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。因此，需要在核心态建立一些“门”，实现从用户态进入核心态。在实际操作系统中，CPU运行上层程序时唯一能进入这些“门”的途径就是通过中断或异常。当中断或异常发生时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的（例如，用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，只需将该位置0即可)。中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。</p><ol><li><p>中断(Interruption)，也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入 / 输出请求，同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们与当前处理机运行的程序无关。</p></li><li><p>异常(Exception)，也称内中断、例外或陷入(Trap)，指源自CPU执行指令内部的事件，如程序的非法操作码、 地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。</p></li></ol><hr><h3 id="系统调用">系统调用</h3><p>所谓系统调用就是用户在程序中调用操作系统所提供的一些子功能，系统调用可以被看做特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I/0传输以及管理文件等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十乃至上百条之多。</p><p>这些系统调用按功能大致可分为如下几类：<br>设备管理。完成设备的请求或释放，以及设备启动等功能。<br>文件管理。完成文件的读、写、创建及删除等功能。<br>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。<br>进程通信。完成进程之间的消息传递或信号传递等功能。<br>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</p><p>显然，系统调用运行在系统的核心态。通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令。系统调用命令是由操作系统提供的一个或多个子程序模块实现的。</p><p>这样，操作系统的运行环境可以理解为：用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。当管理程序运行结束时，用户程序需要继续运行，则通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行。</p><blockquote><p>下面列举一些由用户态转向核心态的例子：<br>用户程序要求操作系统的服务，即系统调用。<br>发生一次中断。<br>用户程序中产生了一个错误状态。<br>用户程序中企图执行一条特权指令。<br>从核心态转向用户态由一条指令实现，这条指令也是特权命令。一般是中断返回指令。</p><p>注意：由用户态进入核心态，不仅仅是状态需要切换。而且，所使用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍历Map的四种方式</title>
      <link href="/2021/10/06/%E9%81%8D%E5%8E%86Map%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/10/06/%E9%81%8D%E5%8E%86Map%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="Entry">Entry</h3><p>由于Map中存放的元素均为键值对，故每一个键值对必然存在一个映射关系。<br>Map中采用Entry内部类来表示一个映射项，映射项包含Key和Value (我们总说键值对键值对, 每一个键值对也就是一个Entry)<br>Map.Entry里面包含getKey()和getValue()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it&#x3D;map.entrySet().iterator();</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;Integer,Integer&gt; entry&#x3D;it.next();</span><br><span class="line">        int key&#x3D;entry.getKey();</span><br><span class="line">        int value&#x3D;entry.getValue();</span><br><span class="line">        System.out.println(key+&quot; &quot;+value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="entrySet">entrySet</h3><p>entrySet是 java中 键-值 对的集合，Set里面的类型是Map.Entry，一般可以通过map.entrySet()得到。</p><p>entrySet实现了Set接口，里面存放的是键值对。一个K对应一个V。<br>用来遍历map的一种方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entryseSet&#x3D;map.entrySet();</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry:entryseSet) &#123;</span><br><span class="line">System.out.println(entry.getKey()+&quot;,&quot;+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即通过getKey（）得到K，getValue得到V。</p><h3 id="keySet">keySet</h3><p>还有一种是keySet, keySet是键的集合，Set里面的类型即key的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set &#x3D; map.keySet();</span><br><span class="line">for (String s:set) &#123;</span><br><span class="line">System.out.println(s+&quot;,&quot;+map.get(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四种遍历Map方式">四种遍历Map方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(&quot;1&quot;, &quot;value1&quot;);</span><br><span class="line">map.put(&quot;2&quot;, &quot;value2&quot;);</span><br><span class="line">map.put(&quot;3&quot;, &quot;value3&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第一种：普遍使用，二次取值</span><br><span class="line">System.out.println(&quot;通过Map.keySet遍历key和value：&quot;);</span><br><span class="line">for (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(&quot;key&#x3D; &quot;+ key + &quot; and value&#x3D; &quot; + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二种</span><br><span class="line">System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;);</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it &#x3D; map.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; entry &#x3D; it.next();</span><br><span class="line">    System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第三种：推荐，尤其是容量大时</span><br><span class="line">System.out.println(&quot;通过Map.entrySet遍历key和value&quot;);</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第四种</span><br><span class="line">System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;);</span><br><span class="line">for (String v : map.values()) &#123;</span><br><span class="line">    System.out.println(&quot;value&#x3D; &quot; + v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的容器类及区别</title>
      <link href="/2021/10/05/java%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/05/java%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="分类：大类型主要分为以下两种类型">分类：大类型主要分为以下两种类型</h3><p>１）Collection：一个独立元素的序列，这些元素都服从一条或者多条规则。 List必须按照插入的顺序保存元素，而set不能有重复的元素。Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。</p><p>2）Map：一组成对的“键值对”对象，允许你使用键来查找值。</p><img src="/img/pg/col.png" alt="col" style="zoom:75%;" /><h3 id="具体区别">具体区别</h3><p>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主要方法:</span><br><span class="line">boolean add(0bject o) 添加对象到集合</span><br><span class="line">boolean remove (0bject o)删除指定的对象</span><br><span class="line">int size()返回当前集合中元素的数量</span><br><span class="line">boolean contains (0bject 0)查找集合中是否有指定的对象</span><br><span class="line">boolean isEmpty()判断集合是否为空</span><br><span class="line">Iterator iterator()返回- 一个迭代器</span><br><span class="line">boolean containsAll(Collection c)查找集合中是否有集合c中的元素</span><br><span class="line">boolean addAll(Collection c)将集合c中所有的元素添加给该集合</span><br><span class="line">void clear()删除集合中所有元素</span><br><span class="line">void removeAll(Collection c)从集合中删除c集合中也有的元素</span><br><span class="line">void retainAll(Collection c)从集合中删除集合c中不包含的元素</span><br></pre></td></tr></table></figure><h4 id="List接口">List接口</h4><p>实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p><p>共同点：</p><p>​      LinkedList、ArrayList都实现了List接口，都是不同步的，线程不安全，元素是有序的、可重复。</p><p>1）LinkedList类</p><p>​     基于链表的数据结构，允许null元素，增加、删除、修改元素方面效率比ArrayList高。   此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p><p><strong>注意:LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…));</strong></p><p>2)ArrayList类</p><p>基于数组的数据结构，不同步，线程不安全，查询（get set）效率高。</p><p>size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p><p><strong>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</strong></p><h4 id="Array和ArrayList的区别及各自适用的场景">Array和ArrayList的区别及各自适用的场景</h4><p>Array是数组，ArrayList是Array的加强版。</p><p>（1）array可以保存基本类型和对象类型，arrayList只能保存对象类型</p><p>（2）array数组的大小是固定的不能更改，而ArrayList的大小可以改变</p><p>（3）Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。</p><p>（4）ArrayList有更加丰富的方法如addAll（）、removeAll()、iterator()</p><p>适用场景：</p><p>如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不经常对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，可以考虑选LinkedList。</p><p>3）Vector类</p><p>Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个 Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。</p><p>4）Stack 类</p><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有 peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p><h4 id="Set接口">Set接口</h4><p>共同点:元素不重复</p><p><strong>1）HashSet类</strong></p><p>-&gt;不保证集合中元素的顺序</p><p>-&gt;允许包含值为null的元素，但最多只能有一个null元素。</p><p><strong>2）TreeSet</strong></p><p>TreeSet描述的是Set的一种变体——可以实现排序等功能的集合，它在将对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中，并保证该集合元素组成的对象序列时刻按照“升序”排列。所以我们在使用TreeSet时候，里面装的元素一定是有序的，否则就不应该选择TreeSet。</p><p><strong>3)LinkedSet</strong></p><p>集合元素按插入顺序排列。</p><p>适用场景：</p><p>HashSet使用哈希表实现的，元素是无序的。添加、删除操作时间复杂度都是O(1)。TreeSet内部结构是一个树结构(红黑树)，元素是有序的，添加、删除操作时间复杂度为O(log(n))，并且提供了first(), last(), headSet(), tailSet()等方法来处理有序集合。</p><p>LinkedHashSet是介于HashSet 和 TreeSet之间，内部是一个双向链表结构，所以它的插入是有序的，时间复杂度是O(1)。</p><p>简而言之,如何你需要的是一个快速的集合，建议你使用HashSet，如果你需要的是一个排序集合，请选择TreeSet，如果你需要一套能够存储插入顺序的集合,请使用LinkedHashSet。</p><h4 id="Map集合接口">Map集合接口</h4><p>Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p><p><strong>HashTable和HashMap区别</strong></p><p>第一、继承不同。</p><p>public class Hashtable extends Dictionary implements Map</p><p>public class HashMap extends AbstractMap implements Map</p><p>第二、Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p><p>第三、Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。<strong>当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</strong></p><p>第四、两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。</p><p>第五、哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p><p>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值。</p><p>Hashtable计算hash值，直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</p><p>第六，内部实现使用的数组初始化和扩容方式不同。</p><p>HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</p><p>Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</p><p>适用场景：</p><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p><p>1、由于HashMap非线程安全，在只有一个线程访问的情况下，效率要高于HashTable</p><p>2、HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p><p>3、HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。因为contains方法容易让人引起误解。</p><p>4、Hashtable继承自陈旧的Dictionary类，而HashMap是Java1.2引进的Map 的一个实现。</p><p>5、两者通过hash值散列到hash表的算法不一样，HashTbale是古老的除留余数法，直接使用hashcode，而后者是强制容量为2的幂，重新根据hashcode计算hash值，在使用hash 位与 （hash表长度 – 1），也等价取膜，但更加高效，取得的位置更加分散，偶数，奇数保证了都会分散到。前者就不能保证。</p><p>6、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p><p>fail-fast和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set方法，将会抛出IllegalArgumentException异常。</p><p>结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p><p>该条说白了就是在使用迭代器的过程中有其他线程在结构上修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p><h4 id="LinkedHashMap和HashMap的区别">LinkedHashMap和HashMap的区别</h4><ul><li>HashMap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。</li><li>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。也可以在构造时带参数，按照应用次数排序。</li><li>LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序插入顺序 、 访问顺序<br>1.插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序<br>2.访问顺序：所谓访问指的是get/put操作，对一个键执行get/put操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的小芝士</title>
      <link href="/2021/09/25/java%E4%B8%AD%E7%9A%84%E5%B0%8F%E8%8A%9D%E5%A3%AB/"/>
      <url>/2021/09/25/java%E4%B8%AD%E7%9A%84%E5%B0%8F%E8%8A%9D%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="JAVA-构造方法和get，set方法的区别与联系">JAVA 构造方法和get，set方法的区别与联系</h3><p>联系：<br>都可以给对象赋值，都可以访问private私有属性<br>区别：<br>构造方法是一次性用品，是初始化对象的时候调用的，而get/set方法则可以多次修改对象的属性<br>构造方法赋值的时候可以不加引用，如：new 类名( , , , ,)，直接可以开辟空间，而get/set方法必须要有引用<br>最终要的一点是在属性私有化的时候，setget方法可以实现从外部类对属性的访问</p><h3 id="怎么判断两个对象是否为同一个对象">怎么判断两个对象是否为同一个对象</h3><h4 id="equals（）">equals（）</h4><p>equals（）是Object中的方法，比较的对象的内存地址</p><h4 id="hashCode（）">hashCode（）</h4><p>比较的哈希码中的索引位置。可以快速定位对象的物理位置，能提高查找效率。</p><p>equals（）相等，hashCode（）一定相等<br>hashCode（）不相等，equals（）一定不相同<br>hashCode（）相等，equals不一定相等</p><h4 id="equals（）和hashCode（）">equals（）和hashCode（）</h4><ul><li><p>​         java中相同对象有两个：1、引用地址符都相同的对象属于同一个对象  2、所指对象的内容完全一致属于同一个对象</p></li><li><p>​         比较两个自定义对象是否属于同一个对象时，我们要重写自定义对象中的equals()方法，否则，当使用equals（）比较时，会自动去调用Object类中的equals（）方法，而Object类中的equals（）方法实则是比较两个对象的引用地址符是否相当，而不会去比较内容是否相等，这样两个不同的的自定义的对象比较时，永远返回的是false.</p></li></ul><blockquote><p>​        在hashSet中使用，hashset是元素无序，不重复的集合。先有一个例子看一下其实hashSet也是可以添加重复元素的。</p><p>​        看这个结果hashSet无序倒是体现出来了，但是里面为什么被添加了重复元素？难道是hashSet元素不可以重复是错误？当然不是啦！首先我们分析一下hashSet中我们是怎么添加元素的，由上图可见我们每次添加的对象都是new出来的，使用new就是创建一个对象，既然每次都创建了一个新的对象，hashCode（）可能就不相同，hashSet自然就把他们当做不同对象添加到集合里面啦。那么对于自定义对象我们才能保持不重复呢？如下：重写自定义对象的equals（）和hashCode（）来比较对象内容后</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override &#x2F;&#x2F;重写hashcode</span><br><span class="line">public int hashCode () &#123;</span><br><span class="line">return this .getId () +this . getName () . hashCode () ;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;重写equals()</span><br><span class="line">@Override</span><br><span class="line">public boolean equals (object obj) &#123;</span><br><span class="line">if (this&#x3D;&#x3D;obj)   &#123;return true ;&#125;</span><br><span class="line">        if (obj instanceof Items) &#123;</span><br><span class="line">Items i &#x3D; (Items) obj ;</span><br><span class="line">if (this.getId()&#x3D;&#x3D; i.getId () &amp;&amp;this.getName().equals(i.getName()))                   &#123;return true ; &#125;</span><br><span class="line">else    &#123; return false ;&#125;</span><br><span class="line">&#125;</span><br><span class="line">else  &#123;return false ;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java堆内存和栈内存的区别">Java堆内存和栈内存的区别</h3><blockquote><ol><li>栈：为编译器自动分配和释放，如函数参数、局部变量、临时变量等等</li><li>堆：为成员分配和释放，由程序员自己申请、自己释放。否则发生内存泄露。典型为使用new申请的堆内容</li><li>静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li></ol></blockquote><p>1.不论对象什么时候创建，他都会存储在堆内存中，栈内存包含它的引用。栈内存只包含原始值变量好和堆中对象变量的引用。</p><p>2.存储在堆中的对象是全局可以被访问的，然而栈内存不能被其他线程所访问。</p><h3 id="引用和对象的关系">引用和对象的关系</h3><p>​      因为在java中对象是没有名字的，所以我们是用引用变量来控制某某类型的对象的， 即通过引用变量来调用这个对象中的成员(成员变量,成员方法).</p><p>Vehicle veh1 = new Vehicle(); 通常把这条语句的动作称之为创建一个对象，其实，它包含了四个动作。</p><p>​      1.new Vehicle，是以Vehicle类为模板，在堆空间里创建一个Vehicle类型的对象（简称为Vehicle对象）。<br>​      2.末尾的()意味着，在对象创建后，立即调用Vehicle类的构造函数,根据括号中有无参数进而来调用相应Vehicle类中的构造方法,对刚生成的对象进行初始化。</p><p>​      3.Vehicle veh 表示在栈中创建了一个Vehicle类型的引用变量。即Vehicle类型的引用。他的作用是可以指向Vehicle类型的对象.即他可以存储Vehicle类型对象在堆中的地址。</p><p>​      4.“=”操作符的作用是使引用变量指向刚刚创建的那个Vehicle对象。或者说将对象在堆中的地址赋值给引用变量<br>即使对象和引用变量之间关联起来。</p><h3 id="LinkedHashMap和HashMap的区别">LinkedHashMap和HashMap的区别</h3><p>区别：</p><ul><li>LinkedHashMap是继承于HashMap，是基于HashMap和双向链表来实现的。</li><li>HashMap无序；LinkedHashMap有序，可分为插入顺序和访问顺序两种。如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。</li><li>LinkedHashMap存取数据，还是跟HashMap一样使用的Entry[]的方式，双向链表只是为了保证顺序。</li><li>LinkedHashMap是线程不安全的。</li></ul><p>应用场景：</p><p>​    HashMap是无序的，当我们希望有顺序地去存储key-value时，就需要使用LinkedHashMap了。</p><h3 id="Java中的强制类型转换">Java中的强制类型转换</h3><p><strong>1 ) 整数 int 转换成字串 String , 有三种方法 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; String.valueOf(i);</span><br><span class="line">String s &#x3D; Integer.toString(i);</span><br><span class="line">String s &#x3D; &quot;&quot; + i;</span><br></pre></td></tr></table></figure><p><strong>2 ) String 转 int</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; Integer.parseInt([String]);</span><br><span class="line">i &#x3D; Integer.parseInt([String],[int radix]);</span><br><span class="line">int i &#x3D; Integer.valueOf(my_str).intValue();</span><br></pre></td></tr></table></figure><p><strong>3 ) 布尔类型 转 String</strong></p><ol><li>第一种方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean bool &#x3D; true;</span><br><span class="line">String s &#x3D; new Boolean(bool).toString();&#x2F;&#x2F;将bool利用对象封装器转化为对象</span><br></pre></td></tr></table></figure><ol start="2"><li>第二种方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean bool &#x3D; true; </span><br><span class="line"></span><br><span class="line">String s &#x3D; String.valueOf( bool );</span><br></pre></td></tr></table></figure><p><strong>4 ) String 转 Date</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导入 java.util.Date date&#x3D;null;</span><br><span class="line"></span><br><span class="line">date&#x3D;java.sql.Date.valueOf(String s);</span><br></pre></td></tr></table></figure><p><strong>5 ) 数字类型间的转换</strong></p><p>转型有两种: 向上转型和向下转型(强制转型)<br>两种分别如下:<br>第一种是向上转型<br>对于基础数据类型 , 可以自动转型 ,比如:<br>int a = 10;<br>long b = a;<br>这里就是把int型转成了long型 , 因为 long范围比int大 , 这样的转型不会有任何影响 , 所以可以自动转型</p><p>第二种是向下转型 , 也就是强制<br>这种需要强转 , 比如<br>long a = 10 ;<br>int b = (int) a;<br>通过 (int)可以强制转型 , 但是这样会丢失精度 , 比如a如果超过了b的范围 , 那么强转成int型, 只会等于int的最大值</p><p>又如 : int a = ( int ) 8.8 ;</p><h3 id="Serializable的使用">Serializable的使用</h3><p>Serializable：可序列化接口。     序列化：将对象转换为字节流。   反序列化：将字节流转换为对象。</p><p>定义实体类会实现Serializable接口，目的就是为了把对象持久化存储或者网络比特流传输。</p><p>Serializable相当于转换层，把对象转换成字节流，传字节流比传比对象实例 更方便机器的存取。传输之前就之后转成字节流，以免传输时进行判断或者占用其他空间、时间 进行 字节流转换。</p><p>serialVersionUID有两种显示的生成方式：<br>一是默认的1L，比如：private static final long serialVersionUID = 1L;<br>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段</p><p>作用是用来验证 对象的发送方和接收方是否已经加载。什么意思：在<strong>反序列化时，<strong>JVM会将传输过来的</strong>serialVersionUID</strong>与本地实体类的对比，如果相同，反序列化成功，若不同则反序列化失败。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java容器的遍历</title>
      <link href="/2021/09/23/java%E5%AE%B9%E5%99%A8%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2021/09/23/java%E5%AE%B9%E5%99%A8%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代器">迭代器</h3><h4 id="迭代器的介绍">迭代器的介绍</h4><p>迭代器是用于遍历集合中的元素的一种方式。Java集合框架中的迭代器是Iterator接口，该接口位于java.util包下</p><h4 id="迭代器的创建和使用">迭代器的创建和使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Object&gt; it&#x3D; c.iterator();&#x2F;&#x2F;获取迭代器对象</span><br></pre></td></tr></table></figure><h5 id="hasNext-方法">hasNext()方法</h5><p>hasNext()方法的作用：判断集合中是否还有元素，如果还有元素可以迭代，则返回true，否则返回false。</p><h5 id="next-方法">next()方法</h5><p>next()方法作用：返回集合中下一个集合元素。该方法一般和hasNext()方法结合使用，当hasNext()方法判断还有下一个元素时，则可以使用next()方法获取到集合元素。</p><h3 id="使用迭代器遍历">使用迭代器遍历</h3><h4 id="迭代器-KeySet">迭代器 KeySet</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Private  HashMap &lt;Items,Integer&gt; goods&#x3D; new HashMap&lt;Items,integer&gt; (); &#x2F;&#x2F;获取商品集合，（integer是一种int的包装类，须实例化使用；Items是商品类）</span><br><span class="line"></span><br><span class="line"> Set&lt;Items&gt; keys&#x3D;goods.keyset();获取键的集合；</span><br><span class="line"> Iterator&lt;Items&gt; it&#x3D;keys.iterator();获取迭代器对象；</span><br><span class="line"> while(it.hasNext())&#123;</span><br><span class="line">   Items i&#x3D;it.Next(); 获取商品对象</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器-EntrySet">迭代器 EntrySet</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private  Hashmap&lt;Items,Integer&gt; goods&#x3D;new Hashmap&lt;Items,Integer&gt;();&#x2F;&#x2F;创建商品集合对象</span><br><span class="line">  Set&lt;Items,Integer&gt; entrys&#x3D;goods.entryset(); 获取键值对集合</span><br><span class="line">  Interator it&#x3D;entrys.Interator();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用Foreach遍历">使用Foreach遍历</h3><p>foreach语句语法类型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型x 元素变量y :遍历对象z)&#123;</span><br><span class="line">    遍历元素变量y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">list.add(&quot;c&quot;);</span><br><span class="line">for(String y :list)&#123;</span><br><span class="line">    System.out.println(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种遍历方式的区别">三种遍历方式的区别</h3><h4 id="条件差别">条件差别</h4><p>for需要知道数组或者集合的大小，而且需要有序的，不然无法遍历；</p><p>foreach和iterator不需要知道数组或者集合的大小，他们都是得到集合内的每一个元素然后进行处理；</p><h4 id="多态差别">多态差别</h4><p>for和foreach都需要知道自己的集合类型，甚至要知道自己集合内的元素类型，不能实现多态。这个使用的语法上都可以表示出来。</p><p>Iterator是一个接口类型，它不关心集合的类型和集合内的元素类型，因为它是通过hasnext和next来进行下一个元素的判断和获取，这一切都是在集合类型定义的时候就完成的事情。迭代器统一了对容器的访问模式，这也是对接口解耦的最好表现。</p><h4 id="用法差别">用法差别</h4><p>for一般可以用于简单的顺序集合，并且可以预测集合的大小；</p><p>foreach可以遍历任何集合或者数组，但是使用者需要知道遍历元素的类型。</p><p>iterator是最强大的，它可以随之修改元素内部的元素。可以在遍历的时刻用remove（）！！！！我的意思是其他两个都不可以！！！</p><p>而且iterator不需要知道元素类型和元素大小，通过hasnext（）判断是否遍历完所有元素。</p><p>而且在对范型的集合进行遍历的时候，iterator是不二的选择，就是因为不需要知道元素类型便可以遍历。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet学习</title>
      <link href="/2021/09/16/Servlet%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/09/16/Servlet%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是servlet">什么是servlet</h3><p>​    在 JavaWeb 项目中，处理请求和发送响应的过程是由一种叫做 Servlet 的程序来完成的，并且 Servlet 是为了解决实现动态页面而衍生的东西。</p><p>简单来讲：Servlet其实就是一个遵循Servlet开发的java类，Serlvet是由服务器调用的，运行在服务器端。</p><h3 id="Tomcat-和-Servlet-的关系">Tomcat 和 Servlet 的关系</h3><p>​     Tomcat 是Web应用服务器，是一个Servlet/JSP容器。 Tomcat 作为 Servlet 容器，负责处理客户请求,把请求传送给 Servlet，并将 Servlet 的响应传送回给客户，而 Servlet 是一种运行在支持 Java 语言的服务器上的组件。</p><p>①：Tomcat 将 Http 请求文本接收并解析，然后封装成 HttpServletRequest 类型的 request 对象，所有的 Http 头数据读可以通过request 对象调用对应的方法查询到。</p><p>②：Tomcat 同时会要响应的信息封装为 HttpServletResponse 类型的response 对象，通过设置 response 属性就可以控制要输出到浏览器的内容，然后将 response 交给 Tomcat，Tomcat 就会将其变成响应文本的格式发送给浏览器。</p><p>Java Servlet API 是Servlet容器(tomcat)和servlet之间的接口，它定义了Serlvet 的各种方法，还定义了 Servlet 容器传送给 Servlet 的对象类，其中最重要的就是 ServletRequest 和 ServletResponse 。所以说我们在编写Servlet时，需要实现 Servlet 接口，按照其规范进行操作。</p><h3 id="编写servlet">编写servlet</h3><p><strong>我们要继承 HttpServlet类 那么问题来了，继承HttpServlet 和实现Servlet 有什么区别？</strong></p><p>首先，直观的不同，Servlet 是一个接口，如果实现这个接口，那么就必须实现接口里面定义的所有方法。</p><p>而 HttpServlet 实现了 Servlet 接口，并把 Servlet 接口中的方法实现了。<br>继承 Httpservelt，实际上也就实现了 Servlet 接口。</p><p>但是我们没必要再去实现 Servlet 中定义的生命周期方法，因为在 Httpservlet 中已经有了默认实现，并且这些默认实现也挺规范和实用， doget 和 dopost 是执行用户请求的终点，get 请求会调用 doget 方法，post 请求会执行 dopost 方法，我们可以在这2个方法中定义我们自己的业务逻辑。</p><p>最后，HttpServlet 在实现 Servlet 接口的时候，已经实现了 Servlet 中所有的方法，因此继承自 HttpSrvlet 的类，不需要再去覆写相应的生命周期等方法。</p><h4 id="编写Java类，继承HttpServlet">编写Java类，继承HttpServlet</h4><p>创建一个 MyServlet java 类，继承 HttpServlet 实现 service 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置字符编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">        <span class="comment">//从 request 对象中获取username,password</span></span><br><span class="line">        String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;password&quot;</span>,password);</span><br><span class="line">        request.getRequestDispatcher( <span class="string">&quot;/index2.jsp&quot;</span>).forward(request, response);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置web-xml文件">配置web.xml文件</h4><p>web.xml 配置 Servlet 访问路径，能让别人通过链接访问到你的 Servlet：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;MyServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;club.sscai.demo.MyServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;MyServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;MyServlet&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure><h4 id="jsp-界面显示">jsp 界面显示</h4><p>index2.jsp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;2222222&lt;&#x2F;h2&gt;</span><br><span class="line">username: &lt;%&#x3D;request.getParameter(&quot;username&quot;) %&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">password: &lt;%&#x3D;request.getParameter(&quot;password&quot;) %&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>前台界面附带的参数，可以通过 request 获取，这也证实了前面 <strong>HttpServletRequest 封装了 request对象，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中。</strong></p><p>关于 request\response，在实际项目开发中，request 是非常常用的，毕竟你要拿到用户请求的信息，才能知道用户要什么，但是，像上文中这种继承自 HttpServlet 是不会出现的，例如，采用 Spring MVC 框架后，自动帮我们实现了 <strong>request 请求到 Controller</strong> 的骚操作。</p><p>servlet中out.write()和out.print()的区别</p><p>重载的print方法可将各种类型的数据转换成字符串的形式输出，而重载的write方法只能输出字符、字符数组和字符串等与字符相关的数据</p><p>字符串比较之中“==”和equals()的区别？</p><p>==：比较的是两个字符串内存地址的数值是否相等，属于数值比较；</p><p>equals()：比较的是两个字符串的内容，属于内容比较。</p><p>以后进行字符串相等判断的时候都使用equals()</p><h3 id="ServletContext与ServletConfig的详解及区别">ServletContext与ServletConfig的详解及区别</h3><h4 id="servletContext详解">servletContext详解</h4><p>​      ServletContext是servlet与servlet容器之间的直接通信的接口。Servlet容器在启动一个Web应用时，会为它创建一个servletContext对象。每个web应用有唯一的servletContext对象。同一个web应用的所有servlet对象共享一个serveltContext,servlet对象可以通过它来访问容器中的各种资源。该接口获取的是web应用的初始化信息。</p><h4 id="servletConfig详解">servletConfig详解</h4><p>​      Servlet容器初始化一个servlet对象时，会为这个servlet对象创建一个servletConfig对象。在servletConfig对象中包含了servlet的初始化参数信息。此外，servletConfig对象还与servletContext对象关联。Servlet容器在调用servlet对象的init(ServletConfig config)方法时，会把servletConfig对象当做参数传递给servlet对象。Init(ServletConfig config)方法会使得当前servlet对象与servletConfig对象建立关联关系。</p><h4 id="二者区别">二者区别</h4><p>首先从作用范围来说，ServletConfig作用于某个特定的Servlet，即从该Servlet实例化，那么就开始有效，但是该Servlet之外的其他Servlet不能访问；ServletContext作用于某个web应用，即在一个web应用中相当于一个全局对象，在Servlet容器启动时就已经加载，对于不同的web应用，有不同的ServletContext。</p><p>其次，来看一下二者参数的使用。如果一个参数为整个web应用所用，那么就配置为ServletContext参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">  &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">  &lt;param-value&gt;gb2312&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure><p>如果一个参数仅为一个Servlet所用，那么就应该配置为ServletConfig参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;affice_add&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;servlet.Affice_add&lt;&#x2F;servlet-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">   &lt;param-name&gt;filepath&lt;&#x2F;param-name&gt;</span><br><span class="line">   &lt;param-value&gt;&#x2F;webContent&#x2F;affice&lt;&#x2F;param-value&gt;</span><br><span class="line">  &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br></pre></td></tr></table></figure><h3 id="5-Servlet中文编码问题">5.Servlet中文编码问题</h3><p>实际遇到更多的乱码情况是浏览器接收响应数据的乱码， 所以我们要做的使响应所回送数据所用字符集 和 浏览器用来解析回送数据所用字符集相同。</p><p>设置浏览器的解码格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>大白话说就是用 content-type 响应头，告诉浏览器我回送过来的数据时 text/html 类型，要用 UTF-8 字符集解码；</p><p>设置好浏览器用于解析响应回送数据的字符集后，现在要设置响应回送的数据字符集，分为两种情况，也就是最开始提到的，处理字节和字符流数据是有差异的：</p><ol><li>使用 response.getWriter() 流写出的的数据乱码解决方式：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置将发送到客户端的响应 的字符编码，只能用于设置 getWritet()的字符编码</span></span><br><span class="line">response.setCharactEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//同时设置浏览器的解码方式</span></span><br><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>需要在调用 getWriter() 方法前 和 响应提交前使用</p></blockquote><ol><li>使用 response.getOutputStream() 流写出的数据乱码解决方式：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端对字符进行编码的时候，指定编码方式</span></span><br><span class="line">response.getOutputStream().write(<span class="string">&quot;汉字&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"><span class="comment">//同时设置浏览器的解码方式</span></span><br><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>字符响应流只用用来输出字符，而字节响应流可以用来输出任何东西</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jsp技术</title>
      <link href="/2021/07/30/Jsp%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/07/30/Jsp%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Java-Server-Pages">什么是Java Server Pages?</h3><p>​    JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p><p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p><p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p><p>JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。</p><h3 id="表单的两种提交方式get和post">表单的两种提交方式get和post</h3><p>定义在<code>&lt;form action=&quot;dologin.jsp&quot; name=&quot;loginForm&quot; method=&quot;提交方式***&quot;&gt;&lt;/form&gt;</code>   动作／名称等顺序无所谓。<br>1.get：以【明文】方式，通过URL提交数据，数据在URL中【可以看到】。提交数据最多不超过【2KB】。安全性较低，但效率比post方式高。适合提交数据量不大，且安全要求不高的数据：比如：搜索、查询等功能。<br>2.post：将用户提交的信息封装在HTML HEADER内。适合提交数据量大，安全性高的用户信息。如：注册、修改、上传等功能。</p><h3 id="request请求">request请求</h3><p><strong>request对象：<strong>客户端的</strong>一次请求</strong>（JSP页面通过request对象请求服务器跳转某一页面，只在该页面中有效，其他页面这个request对象无作用）信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是<strong>HttpServletRequest类</strong>的实例。request对象具有<strong>请求域</strong>，即完成客户端的请求之前，该对象一直有效。</p><p>客户端向服务端传参的方式：</p><p>1.通过表单 post、get方式。</p><blockquote><p>request.setCharacterEncoding(utf-8)解决中文乱码</p></blockquote><p>2.通过URL地址传</p><blockquote><p>service.xml中   设置<code>&lt;connector  URLEncoding=&quot;utf-8&quot;  &gt;</code> 解决中文乱码为防止出现提交表单后产生中文乱码问题，应该在request接收参数之前添加指令<br>&lt;request.setCharacterEncoding(“utf-8”);&gt;<br>注：request.setCharacterEncoding方法无法解决通过URL传递参数所产生的中文乱码问题，可修改Tomcat目录下的conf文件夹下server.xml中&lt;<code>Connector&gt;</code>标签后加入 URLEncoding = “utf-8”</p></blockquote><p>问：用request的getParameterValues获取数组元素并输出。</p><p>在传值页面设置多选项的name一致。比如说都叫favorite。<br>在取值页面用jsp操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    String [] favorites &#x3D; reqquest.getParameterValues(&quot;favorite&quot;);&#x2F;&#x2F;设置string数组接收数组数据。</span><br><span class="line">    for(int i&#x3D;0;i&lt;favorites.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        out.println(favorites[i]+&quot;&amp;nbsp;&amp;nbsp;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>Ps1：String getParameter(String name)//获取单个参数值<br>Ps2：String[] getParameterValues(String name)//获取多个参数值，如获取checkbox的值<br>Ps3：request.setCharacterEncoding(“utf-8”);//解决post请求传递中文参数的乱码问题，设置的编码要与发送请求的页面的编码设置的一致。但是无法解决URL链接传递中文参数的乱码问题<br>Ps4：tomcat/conf/server.xml;//解决get请求和URL链接传递中文参数的乱码问题，可将Connector的URIEncoding=“UTF-8”<br>Ps5：href=“request.jsp?user=李四”//里面写值的时候可以不需要引号//所谓的url传参，就是利用get提交的方法拼接一个带参数的url提交给一个接受的jsp页面，这个jsp页面写在最前面，如上</p><h3 id="out对象">out对象</h3><p>一、什么是缓冲区<br>1、缓冲区：Buffer，所谓缓冲区就是内存的一块区域，用来保存临时数据<br>2、IO输出最原始的就是一个字节一个字节输出，效率很低。缓冲区可以先将多个字节读出来，再一次性的输出，提高效率<br>二、out对象<br>1、out对象是JspWriter类的实例，是向客户端（这里指浏览器）输出内容的常用对象。<br>2、常用方法：<br>· void println()向客户端打印字符<br>· void clear()清除缓冲区的内容。如果在flush之后调用，会抛出异常<br>· void clearBuffer() 也是清除缓冲区内容，但在flush之后不会抛出异常<br>· void flush()将缓冲区内容输出到客户端</p><h3 id="JSP内置对象——请求转发与请求重定向的区别">JSP内置对象——请求转发与请求重定向的区别</h3><p>一、请求重定向：服务端response.sendRedirect(“xx.jsp”)重定向。【客户端行为】：即客户端会访问两次，第一次访问后会立即跳转到第二个重定向页面上，【从本质上讲等于两次请求】，而前一次的请求封装的request对象不会保存，地址栏的URL地址会改变。<br>二、请求转发：服务端request.getRequestDispatcher(“xx.jsp”).forward(request,response)请求转发。forward(request,response)用于保存内置对象request和response。【服务器行为】：服务器会代替客户端去访问转发页面，【从本质是一次请求】，转发后请求对象会保存，地址栏的URL地址不会改变。</p><h3 id="什么是session">什么是session</h3><p>1、session表示客户端与服务器的一次会话<br>2、Web中的session指：用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览网站所花费的时间。<br>3、从上述定义中可以看到，session实际是一个【特定的时间概念】<br>4、服务器的内存中，保存着同用户的session。不同的用户有不同的session。</p><h3 id="session的生命周期-活动">session的生命周期 活动</h3><p>某次会话当中通过超链接打开的新页面属于同一次会话<br>只要当前会话页面没有全部关闭，重新打开新的浏览器窗口访问同意项目资源时属于同一次会话。<br>除非本次会话的所有页面都关闭后再重新访问某个新的jsp或者servlet将会创建新的会话。<br>注意事项：<br>注意原有的会话还存在，只是这个旧的sessionId仍然存在于服务器端，只不过再也没有客户端会携带它然后交予服务器端校验<br>session销毁的三种方式：<br>1:调用session.invalidate()方法<br>2：session过期（超时）<br>3;服务器重新启动<br>设置session超时的两种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tomcat默认session超时时间为30分钟</span><br><span class="line">1：session.setMaxInactiveInterval(时间);&#x2F;&#x2F;单位是秒</span><br><span class="line">2:在web.xml配置</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">&lt;session-timeout&gt;</span><br><span class="line">10</span><br><span class="line">&lt;session-timeout&gt;</span><br><span class="line">&lt;session-config&gt; &#x2F;&#x2F;单位是分钟</span><br></pre></td></tr></table></figure><p>一、http协议的无状态性<br>1、无状态是指，当浏览器发送请求给服务器的时候，服务器会响应。但当同一个浏览器再次发送请求时，服务器不会知道是刚才那个浏览器。<br>2、简单说，服务器【不会保存用户状态】，不会记得客户端是否访问过，所以这就是无状态协议</p><p>jsp状态管理<br>保存用户状态的两大机制<br>1、Session<br>2、Cookie<br>什么是cookie？<br>cookie：是web服务器保存在客户端的一系列文本信息。<br>典型应用一：判断注册用户是否已经登录网站。<br>典型应用二：保存用户浏览记录。<br>cookie的作用：<br>1、对特定对象的追踪。<br>2、保存用户网页浏览记录与习惯。<br>3、简化登录<br>安全风险：容易泄露用户信息</p><p>session与cookie对比<br>1.保存位置：session在服务器端内存，cookie在客户端文本<br>2.保存对象：session保存Object类（保存对象大小没有限制），cookie保存String类型（保存对象大小有限制）<br>3.生存权：session会话结束即销毁，cookie可以长期保存在客户端<br>4.重要性：session安全性更高，保存重要信息，cookie保存不重要的信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Jsp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协议栈如何处理数据</title>
      <link href="/2021/07/26/%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/07/26/%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="协议栈如何处理数据">协议栈如何处理数据</h3><p>(1)创建套接字</p><p>从应用程序收到委托后，协议栈通过TCP协议收发数据的操作可以分为4个阶段。首先是创建套接字，在这个阶段，有协议栈的内部结构、套接字的实体，以及创建套接字的操作过程。</p><p>(2)连接服务器</p><p>接下来是客户端套接字向服务器套接字进行连接的阶段。</p><p>(3)收发数据</p><p>两端的套接字完成连接之后，就进人收发消息的阶段了。在这个阶段,协议栈会将从应用程序收到的数据切成小块并发送给服务器，考虑到通信过程中可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送达服务器，对于没有送达的包要重新发送一次。</p><p>(4)从服务器断开连接并删除套接字<br>收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。断开操作的本质是当消息收发完成后客户端和服务器相互进行确认的过程</p><p>(5)IP与以太网的包收发操作<br>在介绍TCP协议收发消息的操作之后，我们再来看看实际的网络包是如何进行收发的。协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。</p><p>(6)用UDP协议收发数据的操作<br>TCP协议有很多方便的功能，比如网络包出错丢失时可以重发，因此很多应用程序都是使用TCP协议来收发数据的，但这些方便的功能也有帮倒忙的时候，在这种情况下我们还有另外一种叫UDP的协议。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2021/07/02/CSS/"/>
      <url>/2021/07/02/CSS/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CSS的引入方式">1.CSS的引入方式</h3><h4 id="a-内联式CSS">a.  内联式CSS</h4><p>把css代码直接写在现有的HTML标签中，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style &#x3D; &quot;color : red ; font-size : 12px&quot;&gt;文本&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h4 id="b-嵌入式CSS">b. 嵌入式CSS</h4><p>就是可以把css样式代码写在style标签之间。如下面代码实现把三个span标签中的文字设置为红色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; span&#123; color:red; &#125; &lt;&#x2F;style&gt; </span><br></pre></td></tr></table></figure><h4 id="c-嵌入式css样式">c.嵌入式css样式</h4><p>必须写在<code>&lt;style&gt;&lt;/style&gt;</code>之间，并且一般情况下嵌入式css样式写在<code>&lt;head&gt;&lt;/head&gt;</code>之间。</p><h4 id="d-外部式CSS">d.外部式CSS</h4><p>外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以“.css”为扩展名，在head标签内（不是在style标签内）使用link标签将css样式文件链接到HTML文件内，如下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href&#x3D;&quot;style.css&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; &#x2F;&gt; </span><br></pre></td></tr></table></figure><p>​         注意： 1、css样式文件名称以有意义的英文字母命名，如 main.css。 2、rel=“stylesheet” type=“text/css” 是固定写法不可修改。 3、<code>&lt;link&gt;标签位置一般写在&lt;head&gt;标签之内</code>。 这三种样式是有优先级的，记住他们的优先级：内联式 &gt; 嵌入式 &gt; 外部式，但是嵌入式 &gt; 外部式有一个前堤：嵌入式CSS样式的位置一定在外部式的后面。 其实总结来说就是–就近原则(离被设置元素越近优先级越高)。 但注意上面所总结的优先级是有一个前提:内联式，嵌入式，外部式样式表中CSS样式相同权值的情况下。</p><h3 id=""></h3><h3 id="2-CSS中的盒子模型">2.CSS中的盒子模型</h3><h4 id="a-盒子模型中主要的区域：">a.<strong>盒子模型中主要的区域：</strong></h4><p>盒子模型（块级元素）中主要包含元素的宽，高，外边距，边框，内边距以及实际内容。</p><ul><li>Width：主要区域的内容（content）的宽。</li><li>Height：主要区域的内容（content）的宽。</li><li>Margen：外边距。即整个元素和其他元素的距离。</li><li>Border：元素的边框。</li><li>Padding：内边距。即元素的边与内容的距离。</li><li>Content：内容。也就是实际所看到的区域。</li></ul><p>下面的图片说明了盒子模型的区域：</p><p><img src="/img/pg/1350478-20180318130200144-1334747621.gif" alt="img"></p><p>盒子模型的宽度、高度的计算</p><p>而我们平常设置盒子的宽和高往往是指的内容的宽和高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;width:200px; height:18px;&#125;</span><br></pre></td></tr></table></figure><p>此段话代表content所占大小为宽200像素，高为18像素；</p><p>而当我们增加其他三个属性时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">width:200px;</span><br><span class="line">height:18px;</span><br><span class="line">padding:20px;</span><br><span class="line"> border:1px solid red;</span><br><span class="line">margin:10px; &#125;</span><br></pre></td></tr></table></figure><p>效果图为：</p><p><img src="/img/pg/20180716195205144" alt="img"></p><p>所以说当改变盒子四个属性中的任何一个的时候，盒子的总面积都会有所改变。</p><p>最后，盒子总大小的计算公式为：盒子的实际高度X盒子的实际宽度。</p><p><strong>元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</strong></p><p><strong>元素实际宽度（盒子的高度）=上边界+上边框+上填充+内容高度+下填充+下边框+下边界。</strong></p><h4 id="b-盒子模型注意事项">b.盒子模型注意事项</h4><p>​    需注意margin是用来隔开元素与元素的间距;padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不干扰;padding用于元素与内容之间的间隔，让内容与元素之间有一段距离。</p><p>当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充。</p><p>单独使用 padding 属性可以改变上下左右的填充。</p><p><img src="/img/pg/VlwVi.png" alt="img"></p><h4 id="c-css什么时候需要清除浮动？">c.<strong>css什么时候需要清除浮动？</strong></h4><p>当父元素没有设置宽度或者高度的时，又需要子元素撑开父元素的时候需要清除浮动。</p><p>如何清除浮动</p><p>我们说的清除浮动是指清除由于子元素浮动带来父元素高度塌陷的影响。</p><p>解决子盒子浮动父盒子塌陷的问题：</p><p>1.给父盒子添加overflow：hidden属性。[常用]</p><p>2.让父盒子也浮动（前提是父盒子的宽度为100%）。</p><p>3.在父容器的最后添加一个高度为0的空div并且添加clear：both属性。</p><p>4.使用伪对象选择器：：after生成一个空的元素</p><h4 id="d-块级元素">d.块级元素</h4><ol><li><p>标准流模型中的块级盒子，默认宽度是100%；而浮动的块级盒子，宽度不会自动伸展，而是由内容(文字、padding)撑开。浮动后的行级元素会变成块级元素， 可以设置宽度高度等属性值。</p></li><li><p>text-align: center;文字水平居中。 line-height:（与div设置的高度相同）；垂直居中,因为line-height是行高属性，比如设置这个属性高度为35px，你的字体就会被安放在这个高度的中间高度显示，就像居中一样</p></li><li><p>设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。a{display:block;}</p></li></ol><p>块级元素特点：</p><p>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><p>3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript</title>
      <link href="/2021/06/14/Javascript/"/>
      <url>/2021/06/14/Javascript/</url>
      
        <content type="html"><![CDATA[<p>1.一些html标签、事件的含义</p><p>如：<div id="aa">这是内容</div></p><p>我们可以通过 document.getElementById(‘aa’).innerHTML 来获取id为aa的对象的内嵌内容；<br>也可以对某对象插入内容，如 document.getElementById(‘abc’).innerHTML=’这是被插入的内容’;</p><p>2.一些注意事项</p><p>（1）对字符串和数字进行加法运算</p><p>​     如果两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串。</p><p>（2）Undefined 和 Null</p><p>Undefined 这个值表示变量不含有值。可以通过将变量的值设置为 null 来清空变量。这两者的值相等，但数据类型不相同，所以并不绝对相等。</p><p>​    （3）在 JavaScript中，几乎所有的事物都是对象。javaScript 对象是键值对的容器，“键”必须为字符串，“值” 可以是 JavaScript 中包括 null 和 undefined 的任意数据类型。</p><p>对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 <strong>name:value</strong> 对呈现。</p><blockquote><p>var car = {name:“Fiat”, model:500, color:“white”};</p></blockquote><p>在以上实例中，3 个值 (“Fiat”, 500, “white”) 赋予变量 car。JavaScript 对象是变量的容器。</p><p>（4）javaScript对象:属性和方法的容器;</p><p>对象的属性之间一定要用逗号隔开;</p><p>对象的方法定义了一个函数，并作为对象的属性存储。</p><p>对象方法通过添加 <strong>()</strong> 调用 (作为一个函数)。</p><p>（5）assign(url):跳转到指定页面；</p><p>reload(true):刷新当前页面；</p><p>replace(url):用指定网址覆盖当前网页；</p><p>assign()和replace()的区别你可以理解为前者是打开新的页面，后者是覆盖原有页面</p><p>（6）Date对象方法中getDay() 方法可返回表示星期的某一天的数字。返回值是 0（周日） 到 6（周六） 之间的一个整数。getDate()获取当日日期</p>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown-it渲染器测试</title>
      <link href="/2021/06/03/markdown-it%E6%B8%B2%E6%9F%93%E5%99%A8%E8%A1%A8%E6%83%85%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/06/03/markdown-it%E6%B8%B2%E6%9F%93%E5%99%A8%E8%A1%A8%E6%83%85%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-表情">1.  表情</h3><h4 id="1-正常文本间的表情">1.正常文本间的表情</h4><p>看在文字间的情况:art:看在文字间的情况</p><h4 id="2-引用块中的表情">2.引用块中的表情</h4><blockquote><p>:grin:</p><p>:fire:</p></blockquote><hr><h3 id="2-hexo渲染测试">2.hexo渲染测试</h3><h4 id="1-测试HTML">1.测试HTML</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;这是div&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>这是div</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组注意事项</title>
      <link href="/2021/05/31/%E8%AE%A1%E7%BB%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2021/05/31/%E8%AE%A1%E7%BB%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念">基本概念</h3><h4 id="位-bit">位(bit)</h4><p><strong>位是电子计算机中最小的数据单位</strong>。每一位的状态只有两种：0或1，在硬件上利用高电压和低电压两种信号实现；</p><h4 id="字节-Byte-B">字节(Byte, B)</h4><p><strong>字节由</strong>8个位组成，它是存储空间的基本计量单位；</p><h4 id="字">字</h4><p>字由若干个字节组成。因此，字一定为字节的整数倍。字的位数称为字长（注意：字不等于字长乘以字节！字=字长×位）。比如一个8位的CPU，这里的8位指其字长为8位，即单位时间内可以处理8位二进制数，即一个字节数。现在的CPU大部分为64位，即单位时间内可以处理64位二进制数，即8个字节数；</p><h4 id="地址线">地址线</h4><p>用于传输地址信息的数据线，一根地址线可以通过高电平或低电平来区分1或0，因此一根地址线有两个状态：1或0，那么N根地址线可以表示2的n次个不同的状态。（也表示寻址范围)</p><h3 id="寻址范围的计算">寻址范围的计算</h3><h4 id="按字节寻址">按字节寻址</h4><p>寻址范围与地址线根数有关，若有n根地址线，则寻址大小为<strong>2的n次</strong></p><blockquote><p>设有一个1MB容量的存储器，字长32位，问：按字节编址，字编址的寻址范围以及各自的寻址范围大小?</p><p>如果按字节编址，则</p><p>​                 1MB = 2^20B</p><p>​                 1字节=1B=8bit</p><p>​                 2^20B/1B = 2^20</p><p>地址范围为0~(2^20)-1,也就是说需要二十根地址线才能完成对1MB空间的编码，所以地址寄存器为20位,寻址范围大小为2^20=1M</p></blockquote><h4 id="按字寻址">按字寻址</h4><p>寻址和地址线根数，字长有关，若有n根，字长为32位（4个字节),则寻址大小为<strong>2的n次方除以4</strong></p><blockquote><p>如果按字编址，则</p><p>​                  1MB=2^20B</p><p>​                  1字=32bit=4B</p><p>​                 2^20B/4B = 2^18</p><p>地址范围为0~2^18-1，也就是说我们至少要用18根地址线才能完成对1MB空间的编码。因此按字编址的寻址范围是2^18</p></blockquote><blockquote><p>某计算机字长为32，其存储容量为16MB，若按双字编址，它的寻址范围是多少</p><p>按双字变址，故为64位<br>16MB=16<em>1024</em>1024<em>8位，所以16MB可以寻址为：<br>(16</em>1024<em>1024</em>8)/64=2<em>1024</em>1024=2M,</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之路</title>
      <link href="/2021/05/28/java%E4%B9%8B%E8%B7%AF/"/>
      <url>/2021/05/28/java%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/pg/java%E5%AD%A6%E4%B9%A0.png" alt="java学习"></p><p>1.Javascript/html/css基础语法    完成(待提升)</p><ol start="2"><li>BootStrap基础使用了解          完成</li><li>计算机网络基础知识</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广佛游记</title>
      <link href="/2021/05/15/%E5%B9%BF%E4%BD%9B%E6%B8%B8%E8%AE%B0/"/>
      <url>/2021/05/15/%E5%B9%BF%E4%BD%9B%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>——广州——<br>广州作为中国最早开放的城市之一，有些深厚的历史文化底蕴，你可以看到它现代和复古的美丽<br>在来广州之前做足了攻略:fire:，听说沙面是拍照的好景点，第一站就来到了这－沙面</p><p><img src="/img/pg/3163559_e525fce9_1207_2187@2312x2312.jpeg.m.jpg" alt="img"></p><p>沙面</p><p>这附近有着不少的旧式风格的建筑，确实是拍照的好地方（漂亮小姐姐也挺多的!），不少人都带着专业的摄像机。</p><p><img src="/img/pg/3163559_9f240a5c_1207_2189@2312x2312.jpeg.m.jpg" alt="img"></p><p>这好像是在织布</p><p>之后来到了圣心大教堂，或许是五一游客太多，为了限制人流，现在只有教徒凭票才能进去，普通游客不能进去。</p><p><img src="/img/pg/3163559_20e37df3_1207_2191@2312x2312.jpeg.m.jpg" alt="img"></p><p>来到了广州，肯定要看的是俗称“小蛮腰”的广州塔啦。</p><p><img src="/img/pg/3163559_e2d2653f_1207_2195@2312x2312.jpeg.m.jpg" alt="img"></p><p>广州大剧院</p><p>由于我是在五一晚上，你们懂得，一眼望去全是人从众，人实在是多的受不了，所以我取消了第二天晚上登上广州塔的预约，挺遗憾的。最后还是本地的士兵们执勤帮忙疏散人群（辛苦士兵们了），很多辆公交车也被派出运送游客。</p><p><img src="/img/pg/3163559_cb4765ec_1207_2197@2312x2312.jpeg.m.jpg" alt="img"></p><p>“小蛮腰”－广州塔</p><p>——佛山——<br>佛山是武术之乡，这里有着叶问，黄飞鸿等一代武术大师。<br>祖庙是当地有名的旅游景点，这地方挺大的，花了挺多时间游玩</p><p><img src="/img/pg/3163559_39812ff5_1207_2199@2312x2312.jpeg.m.jpg" alt="img"></p><p>园林风格</p><p><img src="/img/pg/3163559_96c0880d_1207_2202@2312x2312.jpeg.m.jpg" alt="img"></p><p>在这你也可以看到园林风格的美。</p><p><img src="/img/pg/3163559_1fe6304b_1207_2208@2122x2122.jpeg.m.jpg" alt="img"></p><p>许愿池</p><p>这许愿池真的好多乌龟，（话说这石像是玄武吗），不少游客向其中投入硬币，祈求愿望。</p><p><img src="/img/pg/3163559_c2612488_1207_2212@2312x2312.jpeg.m.jpg" alt="img"></p><p>有关黄飞鸿电影画面的图片</p><p>在祖庙里有着黄飞鸿纪念馆，介绍了武术大师黄飞鸿的生平。这附近甚至也有以他命名的步行街。</p><p><img src="/img/pg/3163559_1c968e51_1221_1779@2312x2312.jpeg.m.jpg" alt="img"></p><p>一条美食街</p><p>同样一代宗师叶问的纪念馆也坐落于祖庙，在馆前你能免费拍照，得到一张6寸照。<br>来到广东，美食也是必须尝试的啦，姜撞奶，双皮奶，糖水类等都值得尝试，比较出名的店有辉记甜品店，但人有点多</p><p><img src="/img/pg/3163559_60b276c3_1221_1781@2312x2312.jpeg.m.jpg" alt="img"></p><p>一下吃多了龟苓膏会觉得有点苦</p><p><img src="/img/pg/3163559_19b70b01_1221_1783@2312x2312.jpeg.m.jpg" alt="img"></p><p>吃起来觉得有点辣</p><p>（第一次写图文，排版有点差），大概就这些啦。<a href="https://www.coolapk.com/feed/26716729?shareKey=MzU1MmQxNzQ0OTNlNjA5ZjFkNDM~&amp;shareUid=3163559&amp;shareFrom=com.coolapk.market_11.1.5.1">转自酷安</a></p>]]></content>
      
      
      <categories>
          
          <category> 生活派 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shop system</title>
      <link href="/2021/04/11/shop-system/"/>
      <url>/2021/04/11/shop-system/</url>
      
        <content type="html"><![CDATA[<ul><li><p>​    <strong>预知</strong>：Java项目中大致分为三层：</p><p>【1】<strong>控制层</strong>（controller）的职能是负责读取视图表现层的数据，控制用户的输入，并调用业务层的方法；</p><p>【2】<strong>业务层</strong>（service）需要根据系统的实际业务需求进行逻辑代码的编写，有些业务逻辑需要通过与数据库交互的，则业务逻辑层需要调用数据访问层的相关方法实现与数据库的交互，</p><p>【3】<strong>数据访问层</strong>（dao）只负责与数据库的数据交互，将数据进行存储读取操作</p><p>【注释；表现层就是看到的东西，比如你现在看到的当前页面<br>控制层就将你的请求从页面传到后台代码<br>逻辑层就是处理你的请求的代码<br>DAO层就是将数据存到数据库中的代码】</p></li><li><p><strong>项目需求：</strong></p><p>为了便于超市业务的管理而设计的该超市管理系统。</p></li><li><p><strong>功能模块：</strong></p><p>该系统有客户信息管理，购物结算，客户回馈等基本功能</p></li><li><p><strong>项目流程图</strong>：</p><p><img src="/img/pg/shop-system.png" alt="shop-system "></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库中的注意事项</title>
      <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="数据库连接问题"><strong>数据库连接问题</strong></h4><h5 id="解决方法">解决方法</h5><p>​      在导入idea项目后，尝试连接数据库，即使账号密码正确，但连接仍一直失败，报错提示:”error no. 1045 access denied for user ‘root’@‘*****’ (using password:YES)。“ 网上查询得知mysql默认root账号只允许本机(localhost, 127.0.0.1)来连接访问. 因此可采取如下方法解决。</p><blockquote><p>运行  mysql -u root -p</p><p>​               use mysql；</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root’@‘%’ IDENTIFIED BY ‘123456’</p><p>​                 这里的123456为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址。</p><p>lush privileges;      这一步一定要做，不然无法成功！ 这句表示从mysql数据库的grant表中重新加载权限数据</p><p>​              因为MySQL把权限都放在了cache中，所以在做完更改后需要重新加载。</p></blockquote><h5 id="声明">声明</h5><p>一般在一个方法或类的声明处通过throws声明方法或类中可能抛出的异常，而在方法或类内部一般通过throw声明一个准实的异常信息。</p><hr><h4 id=""></h4><h4 id="数据库的部分依赖，完全依赖，传递依赖以及三种范式"><strong>数据库的部分依赖，完全依赖，传递依赖以及三种范式</strong></h4><h5 id="依赖关系">依赖关系</h5><ol><li><strong>部分函数依赖</strong>：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</li></ol><blockquote><p>举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。</p></blockquote><p><strong>完全函数依赖</strong>：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</p><blockquote><p>举个例子：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB.</p></blockquote><p><strong>传递函数依赖</strong>：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p><blockquote><p>举个例子：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A</p></blockquote><h5 id="三种范式"><strong>三种范式</strong></h5><h6 id="1-、第一范式（1NF）">1 、第一范式（1NF）</h6><p>​      在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。<br>所谓第一范式（1NF）是指数据库表的每一列(即每个属性)都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。<strong>简而言之，第一范式就是无重复的列。</strong></p><h6 id="2、-第二范式（2NF）">2、 第二范式（2NF）</h6><p>​    第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。<strong>简而言之，第二范式就是非主属性依赖于主关键字。</strong></p><h6 id="3-、第三范式（3NF）">3 、第三范式（3NF）</h6><p>​     满足第三范式（3NF）必须先满足第二范式（2NF）。在满足第二范式的基础上，切不存在传递函数依赖，那么就是第三范式。<strong>简而言之，第三范式就是属性不依赖于其它非主属性。</strong></p><p><strong>简而言之</strong><br><strong>1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。</strong></p><p><strong>2、第二范式（2NF）：满足第一范式，然后消除部分依赖。</strong></p><p><strong>3、第三范式（3NF）： 满足第二范式，消除传递依赖。</strong></p><p><strong>4、BC范式：满足第三范式，只有码在起决定作用。</strong></p><hr><h4 id="关系模型中各种键的定义和区别"><strong>关系模型中各种键的定义和区别</strong></h4><p><strong>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键</strong></p><p><strong>候选键(candidate key):不含有多余属性的超键称为候选键</strong></p><p><strong>主键(primary key):用户选作元组标识的一个候选键程序主键</strong></p><p>比如一个小范围的所有人，没有重名的，考虑以下属性</p><p>身份证 姓名 性别 年龄</p><ol><li>超键的组合是唯一的，但可能不是最小唯一的</li></ol><blockquote><p>身份证唯一，所以是一个超键</p><p>姓名唯一，所以是一个超键</p><p>（姓名，性别）唯一，所以是一个超键</p><p>（姓名，性别，年龄）唯一，所以是一个超键</p></blockquote><p>2.主键是选中的一个候选键</p><blockquote><p>身份证唯一，而且没有多余属性，所以是一个候选键</p><p>姓名唯一，而且没有多余属性，所以是一个候选键</p></blockquote><ol start="3"><li>主键是选中的一个候选键</li></ol><blockquote><p>考虑输入查询方便性，可以选择 身份证 为主键</p><p>也可以 考虑习惯 选择 姓名 为主键</p></blockquote><p><strong>主属性：候选码的中的一个属性。</strong></p><blockquote><p>选课（学号，课程号），此关系的候选码只有一个，为：【学号、课程号】，故主属性有：学号、课程号</p></blockquote><hr><h4 id="求出关系模式的候选键">求出关系模式的候选键</h4><p>[算法]：按以下步骤求候选键：<br>1.只在FD右部出现的属性，不属于候选码;<br>2.只在FD左部出现的属性，一定存在于某候选码当中;<br>3.外部属性一定存在于任何候选码当中;<br>4.其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码。</p><blockquote><p>R&lt;U,F&gt;,U=(A,B,C,D,E,G),F={AB–&gt;C,CD–&gt;E,E–&gt;A.A–&gt;G},求候选码。</p><p>因G只在右边出现,所以G一定不属于候选码;而B,D只在左边出现,所以B,D一定属于候选码;BD的闭包还是BD,则对BD进行组合,除了G以外,BD可以跟A,C,E进行组合<br>先看ABD<br>ABD本身自包ABD,而AB–&gt;C,CD–&gt;E,A–&gt;G,所以ABD的闭包为ABDCEG=U<br>再看BDC<br>CD–&gt;E,E–&gt;A,A–&gt;G,BDC本身自包,所以BDC的闭包为BDCEAG=U<br>最后看BDE<br>E–&gt;A,A–&gt;G,AB–&gt;C,BDE本身自包,所以BDE的闭包为BDEAGC=U</p><p>因为(ABD)、(BCD)、(BDE)的闭包都是ABCDEG所以本问题的候选码有3个分别是ABC、BCD和BDE</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习派 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>travel</title>
      <link href="/2021/04/06/travel/"/>
      <url>/2021/04/06/travel/</url>
      
        <content type="html"><![CDATA[<p>久违的踏青，天上也下着小雨，路上没有多少行人，自然中的清新感也扫去了心中的烦闷感<img src="../../../../img/pg/e.jpg" alt="e"></p><p><img src="../../../../img/pg/c.jpg" alt="c"></p><p><img src="../../../../img/pg/d.jpg" alt="d"></p><p><img src="../../../../img/pg/b.jpg" alt="b"></p><p><img src="../../../../img/pg/a.jpg" alt="a"></p><p><img src="../../../../img/pg/f.jpg" alt="f"></p><p><img src="/img/pg/g.jpg" alt="g"></p>]]></content>
      
      
      <categories>
          
          <category> 生活派 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背影</title>
      <link href="/2021/03/28/%E8%83%8C%E5%BD%B1/"/>
      <url>/2021/03/28/%E8%83%8C%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<p>我与父亲不相见已二年余了，我最不能忘记的是他的背影。那年冬天，祖母死了，父亲的差使也交卸了，正是祸不单行的日子。我从北京到徐州，打算跟着父亲奔丧回家。到徐州见着父亲,看见满院狼藉的东西，又想起祖母，不禁簌簌地流下眼泪。父亲说，“事已如此，不必难过，好在天无绝人之路!”回家变卖典质，父亲还了亏空;又借钱办了丧事。这些日子，家中光景很是惨淡，一半为了丧事，一半为了父亲赋闲。丧事完毕，父亲要到南京谋事，我也要回北京念书，我们便同行。</p><p>到南京时，有朋友约去游逛，勾留了一日;第二日上午便须渡江到浦口，下午上车北去。父亲因为事忙，本已说定不送我，叫旅馆里一个熟识的茶房陪我同去。他再三嘱咐茶房，甚是仔细。但他终于不放心，怕茶房不妥帖;然后他颠颇踌躇了一会。其实我那年已二十岁，北京已来往过两三次，是没有什么要紧的了。他踌躇了一会，终于决定还是自己送我去。我再三回劝他不必去;他只说，“不要紧，他们去不好!”</p><p>我们过了江，进了车站。我买票，他忙着照看行李。行李太多了，得向脚夫行些小费才可过去。他便又忙着和他们讲价钱。我那时真是聪明过分，总觉他说话不大漂亮，非自己插嘴不可，但他终于讲定了价钱;就送我上车。<img src="/img/pg/1.jpg" alt="1">他给我拣定了靠车门的一张椅子;我将他给我做的紫毛大衣铺好座位。他嘱我路上小心，夜里要警醒些，不要受凉。又嘱托茶房好好照应我。我心里暗笑他的迂;他们只认得钱，托他们只是白托!而且我这样大年纪的人，难道还不能料理自己么?唉，我现在想想，那时真是太聪明了!</p><p>我说道，“爸爸，你走吧。”他往车外看了看说，“我买几个橘子去。你就在此地，不要走动。”我看那边月台的栅栏外有几个卖东西的等着顾客。走到那边月台，须穿过铁道，须跳下去又爬上去父亲是一个胖子，走过去自然要费事些。我本来要去的，他不肯，只好让他去。我看见他戴着黑布小帽，穿着黑布大马褂，深青布棉袍，蹒跚地走到铁道边，慢慢探身下去，尚不大难。可是他穿过铁道，要爬上那边月台，就不容易了。他用两手攀着上面，两脚再向上缩;他肥胖的身子向左微倾，显出努力的样子。这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪。怕他看见，也怕别人看见。我再向外看时，他已抱了朱红的橘子往回走了。过铁道时，他先将橘子散放在地上，自己慢慢爬下，再抱起橘子走。到这边时，我赶紧去搀他。他和我走到车上，将橘子一股脑儿放在我的皮大衣上。<img src="/img/pg/2.jpg" alt="2">于是扑扑衣上的泥土，心里很轻松似的。过一会儿说，“我走了，到那边来信!”我望着他走出去。他走了几步，回过头看见我，说，“进去吧，里边没人。”等他的背影混入来来往往的人里，再找不着了，我便进来坐下，我的眼泪又来了。</p><p>近几年来，父亲和我都是东奔西走，家中光景是一日不如一日。他少年出外谋生，独力支持，做了许多大事。哪知老境却如此颓唐!他触目伤怀，自然情不能自已。情郁于中，自然要发之于外;家庭琐屑便往往触他之怒。他待我渐渐不同往日。但最近两年不见，他终于忘却我的不好，只是惦记着我，惦记着我的儿子。我北来后，他写了一信给我，信中说道：“我身体平安，唯膀子疼痛厉害，举箸提笔，诸多不便，大约大去之期不远矣。”我读到此处，在晶莹的泪光中，又看见那肥胖的、青布棉袍黑布马褂的背影。唉!我不知何时再能与他相见</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
